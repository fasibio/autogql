// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"context"
	"fmt"

	"github.com/fasibio/autogql/runtimehelper"
	"github.com/fasibio/autogql/testservice/graph/db"
	"github.com/fasibio/autogql/testservice/graph/model"
	"gorm.io/gorm/clause"
)

// GetTodo is the resolver for the getTodo field.
func (r *queryResolver) GetTodo(ctx context.Context, id string) (*model.Todo, error) {
	v, okHook := r.Sql.Hooks[string(db.GetTodo)].(db.AutoGqlHookGet[model.Todo, string])
	db := r.Sql.Db
	if okHook {
		var err error
		db, err = v.Received(ctx, r.Sql, id)
		if err != nil {
			return nil, err
		}
	}
	db = runtimehelper.GetPreloadSelection(ctx, db, runtimehelper.GetPreloadsMap(ctx, "Todo"))
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	var res model.Todo
	db = db.First(&res, id)
	if okHook {
		r, err := v.AfterCallDb(ctx, &res)
		if err != nil {
			return nil, err
		}
		res = *r
		r, err = v.BeforeReturn(ctx, &res, db)
		if err != nil {
			return nil, err
		}
		res = *r
	}
	return &res, db.Error
}

// QueryTodo is the resolver for the queryTodo field.
func (r *queryResolver) QueryTodo(ctx context.Context, filter *model.TodoFiltersInput, order *model.TodoOrder, first *int, offset *int) (*model.TodoQueryResult, error) {
	v, okHook := r.Sql.Hooks[string(db.QueryTodo)].(db.AutoGqlHookQuery[model.Todo, model.TodoFiltersInput, model.TodoOrder])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, order, first, offset, err = v.Received(ctx, r.Sql, filter, order, first, offset)
		if err != nil {
			return nil, err
		}
	}
	var res []*model.Todo
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Todo")
	db = runtimehelper.GetPreloadSelection(ctx, db, runtimehelper.GetPreloadsMap(ctx, "data").SubTables[0])
	if filter != nil {
		blackList := make(map[string]struct{})
		sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(db, tableName, false, blackList), "AND")
		db.Where(sql, arguments...)
	}

	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}

	if order != nil {
		if order.Asc != nil {
			db = db.Order(fmt.Sprintf("%s.%s asc", tableName, order.Asc))
		}
		if order.Desc != nil {
			db = db.Order(fmt.Sprintf("%s.%s desc", tableName, order.Desc))
		}
	}
	var total int64
	db.Model(res).Count(&total)
	if first != nil {
		db = db.Limit(*first)
	}
	if offset != nil {
		db = db.Offset(*offset)
	}
	db = db.Find(&res)
	if okHook {
		var err error
		res, err = v.AfterCallDb(ctx, res)
		if err != nil {
			return nil, err
		}
		res, err = v.BeforeReturn(ctx, res, db)
		if err != nil {
			return nil, err
		}
	}
	return &model.TodoQueryResult{
		Data:       res,
		Count:      len(res),
		TotalCount: int(total),
	}, db.Error
}
func (r *Resolver) AddTodoPayload() AddTodoPayloadResolver {
	return &todoPayloadResolver[*model.AddTodoPayload]{r}
}
func (r *Resolver) DeleteTodoPayload() DeleteTodoPayloadResolver {
	return &todoPayloadResolver[*model.DeleteTodoPayload]{r}
}
func (r *Resolver) UpdateTodoPayload() UpdateTodoPayloadResolver {
	return &todoPayloadResolver[*model.UpdateTodoPayload]{r}
}

type todoPayload interface {
	*model.AddTodoPayload | *model.DeleteTodoPayload | *model.UpdateTodoPayload
}

type todoPayloadResolver[T todoPayload] struct {
	*Resolver
}

func (r *todoPayloadResolver[T]) Todo(ctx context.Context, obj T, filter *model.TodoFiltersInput, order *model.TodoOrder, first *int, offset *int) (*model.TodoQueryResult, error) {
	return r.Query().QueryTodo(ctx, filter, order, first, offset)
}
func (r *mutationResolver) AddUser2Todos(ctx context.Context, input model.UserRef2TodosInput) (*model.UpdateTodoPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.AddUser2Todos)].(db.AutoGqlHookMany2Many[model.UserRef2TodosInput, model.UpdateTodoPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, &input)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Todo")
	blackList := make(map[string]struct{})
	sql, arguments := runtimehelper.CombineSimpleQuery(input.Filter.ExtendsDatabaseQuery(r.Sql.Db, tableName, false, blackList), "AND")
	db = db.Model(&model.Todo{}).Where(sql, arguments...)
	var res []*model.Todo
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	db.Find(&res)
	type GroupUsers struct {
		TodoID string
		UserID string
	}
	resIds := make([]map[string]interface{}, 0)
	for _, v := range res {
		for _, v1 := range input.Set {
			tmp := make(map[string]interface{})
			tmp["TodoID"] = v.ID
			tmp["UserID"] = v1
			resIds = append(resIds, tmp)
		}
	}
	d := r.Sql.Db.Model(&GroupUsers{}).Create(resIds)
	result := &model.UpdateTodoPayload{
		Count: int(d.RowsAffected),
	}
	if okHook {
		var err error
		result, err = v.BeforeReturn(ctx, db, result)
		if err != nil {
			return nil, err
		}
	}
	return result, d.Error
}

// AddTodo is the resolver for the addTodo field.
func (r *mutationResolver) AddTodo(ctx context.Context, input []*model.TodoInput) (*model.AddTodoPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.AddTodo)].(db.AutoGqlHookAdd[model.Todo, model.TodoInput, model.AddTodoPayload])
	res := &model.AddTodoPayload{}
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, input)
		if err != nil {
			return nil, err
		}
	}
	obj := make([]model.Todo, len(input))
	for i, v := range input {
		obj[i] = v.MergeToType()
	}
	db = db.Omit(clause.Associations)
	if okHook {
		var err error
		db, obj, err = v.BeforeCallDb(ctx, db, obj)
		if err != nil {
			return nil, err
		}
	}
	db = db.Create(&obj)
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, obj, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// UpdateTodo is the resolver for the updateTodo field.
func (r *mutationResolver) UpdateTodo(ctx context.Context, input model.UpdateTodoInput) (*model.UpdateTodoPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.UpdateTodo)].(db.AutoGqlHookUpdate[model.UpdateTodoInput, model.UpdateTodoPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, &input)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Todo")
	blackList := make(map[string]struct{})
	sql, arguments := runtimehelper.CombineSimpleQuery(input.Filter.ExtendsDatabaseQuery(r.Sql.Db, tableName, false, blackList), "AND")
	obj := model.Todo{}
	db = db.Model(&obj).Where(sql, arguments...)
	update := input.Set.MergeToType()
	if okHook {
		var err error
		db, update, err = v.BeforeCallDb(ctx, db, update)
		if err != nil {
			return nil, err
		}
	}
	db = db.Updates(update)
	res := &model.UpdateTodoPayload{
		Count: int(db.RowsAffected),
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// DeleteTodo is the resolver for the deleteTodo field.
func (r *mutationResolver) DeleteTodo(ctx context.Context, filter model.TodoFiltersInput) (*model.DeleteTodoPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.DeleteTodo)].(db.AutoGqlHookDelete[model.TodoFiltersInput, model.DeleteTodoPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, err = v.Received(ctx, r.Sql, &filter)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Todo")
	blackList := make(map[string]struct{})
	sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(db, tableName, false, blackList), "AND")
	obj := model.Todo{}
	db = db.Where(sql, arguments...)
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	db = db.Delete(&obj)
	msg := fmt.Sprintf("%d rows deleted", db.RowsAffected)
	res := &model.DeleteTodoPayload{
		Count: int(db.RowsAffected),
		Msg:   &msg,
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// GetUser is the resolver for the getUser field.
func (r *queryResolver) GetUser(ctx context.Context, id string) (*model.User, error) {
	v, okHook := r.Sql.Hooks[string(db.GetUser)].(db.AutoGqlHookGet[model.User, string])
	db := r.Sql.Db
	if okHook {
		var err error
		db, err = v.Received(ctx, r.Sql, id)
		if err != nil {
			return nil, err
		}
	}
	db = runtimehelper.GetPreloadSelection(ctx, db, runtimehelper.GetPreloadsMap(ctx, "User"))
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	var res model.User
	db = db.First(&res, id)
	if okHook {
		r, err := v.AfterCallDb(ctx, &res)
		if err != nil {
			return nil, err
		}
		res = *r
		r, err = v.BeforeReturn(ctx, &res, db)
		if err != nil {
			return nil, err
		}
		res = *r
	}
	return &res, db.Error
}

// QueryUser is the resolver for the queryUser field.
func (r *queryResolver) QueryUser(ctx context.Context, filter *model.UserFiltersInput, order *model.UserOrder, first *int, offset *int) (*model.UserQueryResult, error) {
	v, okHook := r.Sql.Hooks[string(db.QueryUser)].(db.AutoGqlHookQuery[model.User, model.UserFiltersInput, model.UserOrder])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, order, first, offset, err = v.Received(ctx, r.Sql, filter, order, first, offset)
		if err != nil {
			return nil, err
		}
	}
	var res []*model.User
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("User")
	db = runtimehelper.GetPreloadSelection(ctx, db, runtimehelper.GetPreloadsMap(ctx, "data").SubTables[0])
	if filter != nil {
		blackList := make(map[string]struct{})
		sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(db, tableName, false, blackList), "AND")
		db.Where(sql, arguments...)
	}

	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}

	if order != nil {
		if order.Asc != nil {
			db = db.Order(fmt.Sprintf("%s.%s asc", tableName, order.Asc))
		}
		if order.Desc != nil {
			db = db.Order(fmt.Sprintf("%s.%s desc", tableName, order.Desc))
		}
	}
	var total int64
	db.Model(res).Count(&total)
	if first != nil {
		db = db.Limit(*first)
	}
	if offset != nil {
		db = db.Offset(*offset)
	}
	db = db.Find(&res)
	if okHook {
		var err error
		res, err = v.AfterCallDb(ctx, res)
		if err != nil {
			return nil, err
		}
		res, err = v.BeforeReturn(ctx, res, db)
		if err != nil {
			return nil, err
		}
	}
	return &model.UserQueryResult{
		Data:       res,
		Count:      len(res),
		TotalCount: int(total),
	}, db.Error
}
func (r *Resolver) AddUserPayload() AddUserPayloadResolver {
	return &userPayloadResolver[*model.AddUserPayload]{r}
}
func (r *Resolver) DeleteUserPayload() DeleteUserPayloadResolver {
	return &userPayloadResolver[*model.DeleteUserPayload]{r}
}
func (r *Resolver) UpdateUserPayload() UpdateUserPayloadResolver {
	return &userPayloadResolver[*model.UpdateUserPayload]{r}
}

type userPayload interface {
	*model.AddUserPayload | *model.DeleteUserPayload | *model.UpdateUserPayload
}

type userPayloadResolver[T userPayload] struct {
	*Resolver
}

func (r *userPayloadResolver[T]) User(ctx context.Context, obj T, filter *model.UserFiltersInput, order *model.UserOrder, first *int, offset *int) (*model.UserQueryResult, error) {
	return r.Query().QueryUser(ctx, filter, order, first, offset)
}

// AddUser is the resolver for the addUser field.
func (r *mutationResolver) AddUser(ctx context.Context, input []*model.UserInput) (*model.AddUserPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.AddUser)].(db.AutoGqlHookAdd[model.User, model.UserInput, model.AddUserPayload])
	res := &model.AddUserPayload{}
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, input)
		if err != nil {
			return nil, err
		}
	}
	obj := make([]model.User, len(input))
	for i, v := range input {
		obj[i] = v.MergeToType()
	}
	db = db.Omit(clause.Associations)
	if okHook {
		var err error
		db, obj, err = v.BeforeCallDb(ctx, db, obj)
		if err != nil {
			return nil, err
		}
	}
	db = db.Create(&obj)
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, obj, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model.UpdateUserInput) (*model.UpdateUserPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.UpdateUser)].(db.AutoGqlHookUpdate[model.UpdateUserInput, model.UpdateUserPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, &input)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("User")
	blackList := make(map[string]struct{})
	sql, arguments := runtimehelper.CombineSimpleQuery(input.Filter.ExtendsDatabaseQuery(r.Sql.Db, tableName, false, blackList), "AND")
	obj := model.User{}
	db = db.Model(&obj).Where(sql, arguments...)
	update := input.Set.MergeToType()
	if okHook {
		var err error
		db, update, err = v.BeforeCallDb(ctx, db, update)
		if err != nil {
			return nil, err
		}
	}
	db = db.Updates(update)
	res := &model.UpdateUserPayload{
		Count: int(db.RowsAffected),
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, filter model.UserFiltersInput) (*model.DeleteUserPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.DeleteUser)].(db.AutoGqlHookDelete[model.UserFiltersInput, model.DeleteUserPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, err = v.Received(ctx, r.Sql, &filter)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("User")
	blackList := make(map[string]struct{})
	sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(db, tableName, false, blackList), "AND")
	obj := model.User{}
	db = db.Where(sql, arguments...)
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	db = db.Delete(&obj)
	msg := fmt.Sprintf("%d rows deleted", db.RowsAffected)
	res := &model.DeleteUserPayload{
		Count: int(db.RowsAffected),
		Msg:   &msg,
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}
