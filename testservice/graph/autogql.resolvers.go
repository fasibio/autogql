// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"context"
	"fmt"
	"strings"

	"github.com/99designs/gqlgen/graphql"
	"github.com/fasibio/autogql/runtimehelper"
	"github.com/fasibio/autogql/testservice/graph/db"
	"github.com/fasibio/autogql/testservice/graph/model"
	"github.com/huandu/xstrings"
	"gorm.io/gorm/clause"
)

// GetCat is the resolver for the getCat field.
func (r *queryResolver) GetCat(ctx context.Context, id int) (*model.Cat, error) {
	v, okHook := r.Sql.Hooks[string(db.GetCat)].(db.AutoGqlHookGet[model.Cat, int])
	db := r.Sql.Db
	if okHook {
		var err error
		db, err = v.Received(ctx, r.Sql, id)
		if err != nil {
			return nil, err
		}
	}
	db = runtimehelper.GetPreloadSelection(ctx, db, runtimehelper.GetPreloadsMap(ctx, "Cat"))
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	var res model.Cat
	db = db.First(&res, "id = ?", id)
	if okHook {
		r, err := v.AfterCallDb(ctx, &res)
		if err != nil {
			return nil, err
		}
		res = *r
		r, err = v.BeforeReturn(ctx, &res, db)
		if err != nil {
			return nil, err
		}
		res = *r
	}
	return &res, db.Error
}

// QueryCat is the resolver for the queryCat field.
func (r *queryResolver) QueryCat(ctx context.Context, filter *model.CatFiltersInput, order *model.CatOrder, first *int, offset *int, group []model.CatGroup) (*model.CatQueryResult, error) {
	v, okHook := r.Sql.Hooks[string(db.QueryCat)].(db.AutoGqlHookQuery[model.Cat, model.CatFiltersInput, model.CatOrder])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, order, first, offset, err = v.Received(ctx, r.Sql, filter, order, first, offset)
		if err != nil {
			return nil, err
		}
	}
	var res []*model.Cat
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Cat")
	preloadSubTables := runtimehelper.GetPreloadsMap(ctx, "data").SubTables
	if len(preloadSubTables) > 0 {
		db = runtimehelper.GetPreloadSelection(ctx, db, preloadSubTables[0])
	}
	if filter != nil {
		blackList := make(map[string]struct{})
		sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(db, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
		db.Where(sql, arguments...)
	}
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	if order != nil {
		if order.Asc != nil {
			db = db.Order(fmt.Sprintf("%[1]s%[2]s%[1]s.%[1]s%[3]s%[1]s asc", runtimehelper.GetQuoteChar(db), tableName, order.Asc))
		}
		if order.Desc != nil {
			db = db.Order(fmt.Sprintf("%[1]s%[2]s%[1]s.%[1]s%[3]s%[1]s desc", runtimehelper.GetQuoteChar(db), tableName, order.Desc))
		}
	}
	var total int64
	db.Model(res).Count(&total)
	if first != nil {
		db = db.Limit(*first)
	}
	if offset != nil {
		db = db.Offset(*offset)
	}
	if len(group) > 0 {
		garr := make([]string, len(group))
		for i, g := range group {
			garr[i] = fmt.Sprintf("%s.%s", tableName, xstrings.ToSnakeCase(string(g)))
		}
		db = db.Group(strings.Join(garr, ","))
	}
	db = db.Find(&res)
	if okHook {
		var err error
		res, err = v.AfterCallDb(ctx, res)
		if err != nil {
			return nil, err
		}
		res, err = v.BeforeReturn(ctx, res, db)
		if err != nil {
			return nil, err
		}
	}
	return &model.CatQueryResult{
		Data:       res,
		Count:      len(res),
		TotalCount: int(total),
	}, db.Error
}
func (r *Resolver) AddCatPayload() AddCatPayloadResolver {
	return &catPayloadResolver[*model.AddCatPayload]{r}
}
func (r *Resolver) DeleteCatPayload() DeleteCatPayloadResolver {
	return &catPayloadResolver[*model.DeleteCatPayload]{r}
}
func (r *Resolver) UpdateCatPayload() UpdateCatPayloadResolver {
	return &catPayloadResolver[*model.UpdateCatPayload]{r}
}

type catPayload interface {
	*model.AddCatPayload | *model.DeleteCatPayload | *model.UpdateCatPayload
}

type catPayloadResolver[T catPayload] struct {
	*Resolver
}

func (r *catPayloadResolver[T]) Cat(ctx context.Context, obj T, filter *model.CatFiltersInput, order *model.CatOrder, first *int, offset *int, group []model.CatGroup) (*model.CatQueryResult, error) {
	q := r.Query().(*queryResolver)
	return q.QueryCat(ctx, filter, order, first, offset, group)
}

// AddCat is the resolver for the addCat field.
func (r *mutationResolver) AddCat(ctx context.Context, input []*model.CatInput) (*model.AddCatPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.AddCat)].(db.AutoGqlHookAdd[model.Cat, model.CatInput, model.AddCatPayload])
	res := &model.AddCatPayload{}
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, input)
		if err != nil {
			return nil, err
		}
	}
	obj := make([]model.Cat, len(input))
	for i, v := range input {
		obj[i] = v.MergeToType()
	}
	db = db.Omit(clause.Associations)
	if okHook {
		var err error
		db, obj, err = v.BeforeCallDb(ctx, db, obj)
		if err != nil {
			return nil, err
		}
	}
	db = db.Create(&obj)
	affectedRes := make([]*model.Cat, len(obj))
	for i, v := range obj {
		tmp := v
		affectedRes[i] = &tmp
	}
	res.Affected = affectedRes
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, obj, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// UpdateCat is the resolver for the updateCat field.
func (r *mutationResolver) UpdateCat(ctx context.Context, input model.UpdateCatInput) (*model.UpdateCatPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.UpdateCat)].(db.AutoGqlHookUpdate[model.UpdateCatInput, model.UpdateCatPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, &input)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Cat")
	blackList := make(map[string]struct{})
	queryDb := db.Select(tableName + ".id")
	sql, arguments := runtimehelper.CombineSimpleQuery(input.Filter.ExtendsDatabaseQuery(queryDb, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
	obj := model.Cat{}
	queryDb = queryDb.Model(&obj).Where(sql, arguments...)
	var toChange []model.Cat
	queryDb.Find(&toChange)
	update := input.Set.MergeToType()
	if okHook {
		var err error
		db, update, err = v.BeforeCallDb(ctx, db, update)
		if err != nil {
			return nil, err
		}
	}
	ids := make([]int, len(toChange))
	for i, one := range toChange {
		ids[i] = one.ID
	}
	db = db.Model(&obj).Where("id IN ?", ids).Updates(update)
	affectedRes := make([]*model.Cat, 0)
	subTables := runtimehelper.GetPreloadsMap(ctx, "affected").SubTables
	if len(subTables) > 0 {
		if preloadMap := subTables[0]; len(preloadMap.Fields) > 0 {
			affectedDb := runtimehelper.GetPreloadSelection(ctx, db, preloadMap)
			affectedDb = affectedDb.Model(&obj)
			affectedDb.Find(&affectedRes)
		}
	}

	res := &model.UpdateCatPayload{
		Count:    int(db.RowsAffected),
		Affected: affectedRes,
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// DeleteCat is the resolver for the deleteCat field.
func (r *mutationResolver) DeleteCat(ctx context.Context, filter model.CatFiltersInput) (*model.DeleteCatPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.DeleteCat)].(db.AutoGqlHookDelete[model.CatFiltersInput, model.DeleteCatPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, err = v.Received(ctx, r.Sql, &filter)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Cat")
	blackList := make(map[string]struct{})
	queryDb := db.Select(tableName + ".id")
	sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(queryDb, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
	obj := model.Cat{}
	queryDb = queryDb.Model(&obj).Where(sql, arguments...)
	var toChange []model.Cat
	queryDb.Find(&toChange)
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	ids := make([]int, len(toChange))
	for i, one := range toChange {
		ids[i] = one.ID
	}
	db = db.Model(&obj).Where("id IN ?", ids).Delete(&obj)
	msg := fmt.Sprintf("%d rows deleted", db.RowsAffected)
	res := &model.DeleteCatPayload{
		Count: int(db.RowsAffected),
		Msg:   &msg,
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// GetCompany is the resolver for the getCompany field.
func (r *queryResolver) GetCompany(ctx context.Context, id int) (*model.Company, error) {
	v, okHook := r.Sql.Hooks[string(db.GetCompany)].(db.AutoGqlHookGet[model.Company, int])
	db := r.Sql.Db
	if okHook {
		var err error
		db, err = v.Received(ctx, r.Sql, id)
		if err != nil {
			return nil, err
		}
	}
	db = runtimehelper.GetPreloadSelection(ctx, db, runtimehelper.GetPreloadsMap(ctx, "Company"))
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	var res model.Company
	db = db.First(&res, "id = ?", id)
	if okHook {
		r, err := v.AfterCallDb(ctx, &res)
		if err != nil {
			return nil, err
		}
		res = *r
		r, err = v.BeforeReturn(ctx, &res, db)
		if err != nil {
			return nil, err
		}
		res = *r
	}
	return &res, db.Error
}

// QueryCompany is the resolver for the queryCompany field.
func (r *queryResolver) QueryCompany(ctx context.Context, filter *model.CompanyFiltersInput, order *model.CompanyOrder, first *int, offset *int, group []model.CompanyGroup) (*model.CompanyQueryResult, error) {
	v, okHook := r.Sql.Hooks[string(db.QueryCompany)].(db.AutoGqlHookQuery[model.Company, model.CompanyFiltersInput, model.CompanyOrder])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, order, first, offset, err = v.Received(ctx, r.Sql, filter, order, first, offset)
		if err != nil {
			return nil, err
		}
	}
	var res []*model.Company
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Company")
	preloadSubTables := runtimehelper.GetPreloadsMap(ctx, "data").SubTables
	if len(preloadSubTables) > 0 {
		db = runtimehelper.GetPreloadSelection(ctx, db, preloadSubTables[0])
	}
	if filter != nil {
		blackList := make(map[string]struct{})
		sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(db, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
		db.Where(sql, arguments...)
	}
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	if order != nil {
		if order.Asc != nil {
			db = db.Order(fmt.Sprintf("%[1]s%[2]s%[1]s.%[1]s%[3]s%[1]s asc", runtimehelper.GetQuoteChar(db), tableName, order.Asc))
		}
		if order.Desc != nil {
			db = db.Order(fmt.Sprintf("%[1]s%[2]s%[1]s.%[1]s%[3]s%[1]s desc", runtimehelper.GetQuoteChar(db), tableName, order.Desc))
		}
	}
	var total int64
	db.Model(res).Count(&total)
	if first != nil {
		db = db.Limit(*first)
	}
	if offset != nil {
		db = db.Offset(*offset)
	}
	if len(group) > 0 {
		garr := make([]string, len(group))
		for i, g := range group {
			garr[i] = fmt.Sprintf("%s.%s", tableName, xstrings.ToSnakeCase(string(g)))
		}
		db = db.Group(strings.Join(garr, ","))
	}
	db = db.Find(&res)
	if okHook {
		var err error
		res, err = v.AfterCallDb(ctx, res)
		if err != nil {
			return nil, err
		}
		res, err = v.BeforeReturn(ctx, res, db)
		if err != nil {
			return nil, err
		}
	}
	return &model.CompanyQueryResult{
		Data:       res,
		Count:      len(res),
		TotalCount: int(total),
	}, db.Error
}
func (r *Resolver) AddCompanyPayload() AddCompanyPayloadResolver {
	return &companyPayloadResolver[*model.AddCompanyPayload]{r}
}
func (r *Resolver) DeleteCompanyPayload() DeleteCompanyPayloadResolver {
	return &companyPayloadResolver[*model.DeleteCompanyPayload]{r}
}
func (r *Resolver) UpdateCompanyPayload() UpdateCompanyPayloadResolver {
	return &companyPayloadResolver[*model.UpdateCompanyPayload]{r}
}

type companyPayload interface {
	*model.AddCompanyPayload | *model.DeleteCompanyPayload | *model.UpdateCompanyPayload
}

type companyPayloadResolver[T companyPayload] struct {
	*Resolver
}

func (r *companyPayloadResolver[T]) Company(ctx context.Context, obj T, filter *model.CompanyFiltersInput, order *model.CompanyOrder, first *int, offset *int, group []model.CompanyGroup) (*model.CompanyQueryResult, error) {
	q := r.Query().(*queryResolver)
	return q.QueryCompany(ctx, filter, order, first, offset, group)
}

// AddCompany is the resolver for the addCompany field.
func (r *mutationResolver) AddCompany(ctx context.Context, input []*model.CompanyInput) (*model.AddCompanyPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.AddCompany)].(db.AutoGqlHookAdd[model.Company, model.CompanyInput, model.AddCompanyPayload])
	res := &model.AddCompanyPayload{}
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, input)
		if err != nil {
			return nil, err
		}
	}
	obj := make([]model.Company, len(input))
	for i, v := range input {
		obj[i] = v.MergeToType()
	}
	db = db.Omit(clause.Associations)
	if okHook {
		var err error
		db, obj, err = v.BeforeCallDb(ctx, db, obj)
		if err != nil {
			return nil, err
		}
	}
	db = db.Create(&obj)
	affectedRes := make([]*model.Company, len(obj))
	for i, v := range obj {
		tmp := v
		affectedRes[i] = &tmp
	}
	res.Affected = affectedRes
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, obj, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// UpdateCompany is the resolver for the updateCompany field.
func (r *mutationResolver) UpdateCompany(ctx context.Context, input model.UpdateCompanyInput) (*model.UpdateCompanyPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.UpdateCompany)].(db.AutoGqlHookUpdate[model.UpdateCompanyInput, model.UpdateCompanyPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, &input)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Company")
	blackList := make(map[string]struct{})
	queryDb := db.Select(tableName + ".id")
	sql, arguments := runtimehelper.CombineSimpleQuery(input.Filter.ExtendsDatabaseQuery(queryDb, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
	obj := model.Company{}
	queryDb = queryDb.Model(&obj).Where(sql, arguments...)
	var toChange []model.Company
	queryDb.Find(&toChange)
	update := input.Set.MergeToType()
	if okHook {
		var err error
		db, update, err = v.BeforeCallDb(ctx, db, update)
		if err != nil {
			return nil, err
		}
	}
	ids := make([]int, len(toChange))
	for i, one := range toChange {
		ids[i] = one.ID
	}
	db = db.Model(&obj).Where("id IN ?", ids).Updates(update)
	affectedRes := make([]*model.Company, 0)
	subTables := runtimehelper.GetPreloadsMap(ctx, "affected").SubTables
	if len(subTables) > 0 {
		if preloadMap := subTables[0]; len(preloadMap.Fields) > 0 {
			affectedDb := runtimehelper.GetPreloadSelection(ctx, db, preloadMap)
			affectedDb = affectedDb.Model(&obj)
			affectedDb.Find(&affectedRes)
		}
	}

	res := &model.UpdateCompanyPayload{
		Count:    int(db.RowsAffected),
		Affected: affectedRes,
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// DeleteCompany is the resolver for the deleteCompany field.
func (r *mutationResolver) DeleteCompany(ctx context.Context, filter model.CompanyFiltersInput) (*model.DeleteCompanyPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.DeleteCompany)].(db.AutoGqlHookDelete[model.CompanyFiltersInput, model.DeleteCompanyPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, err = v.Received(ctx, r.Sql, &filter)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Company")
	blackList := make(map[string]struct{})
	queryDb := db.Select(tableName + ".id")
	sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(queryDb, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
	obj := model.Company{}
	queryDb = queryDb.Model(&obj).Where(sql, arguments...)
	var toChange []model.Company
	queryDb.Find(&toChange)
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	ids := make([]int, len(toChange))
	for i, one := range toChange {
		ids[i] = one.ID
	}
	db = db.Model(&obj).Where("id IN ?", ids).Delete(&obj)
	msg := fmt.Sprintf("%d rows deleted", db.RowsAffected)
	res := &model.DeleteCompanyPayload{
		Count: int(db.RowsAffected),
		Msg:   &msg,
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// GetSmartPhone is the resolver for the getSmartPhone field.
func (r *queryResolver) GetSmartPhone(ctx context.Context, id int) (*model.SmartPhone, error) {
	v, okHook := r.Sql.Hooks[string(db.GetSmartPhone)].(db.AutoGqlHookGet[model.SmartPhone, int])
	db := r.Sql.Db
	if okHook {
		var err error
		db, err = v.Received(ctx, r.Sql, id)
		if err != nil {
			return nil, err
		}
	}
	db = runtimehelper.GetPreloadSelection(ctx, db, runtimehelper.GetPreloadsMap(ctx, "SmartPhone"))
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	var res model.SmartPhone
	db = db.First(&res, "id = ?", id)
	if okHook {
		r, err := v.AfterCallDb(ctx, &res)
		if err != nil {
			return nil, err
		}
		res = *r
		r, err = v.BeforeReturn(ctx, &res, db)
		if err != nil {
			return nil, err
		}
		res = *r
	}
	return &res, db.Error
}

// QuerySmartPhone is the resolver for the querySmartPhone field.
func (r *queryResolver) QuerySmartPhone(ctx context.Context, filter *model.SmartPhoneFiltersInput, order *model.SmartPhoneOrder, first *int, offset *int, group []model.SmartPhoneGroup) (*model.SmartPhoneQueryResult, error) {
	v, okHook := r.Sql.Hooks[string(db.QuerySmartPhone)].(db.AutoGqlHookQuery[model.SmartPhone, model.SmartPhoneFiltersInput, model.SmartPhoneOrder])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, order, first, offset, err = v.Received(ctx, r.Sql, filter, order, first, offset)
		if err != nil {
			return nil, err
		}
	}
	var res []*model.SmartPhone
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("SmartPhone")
	preloadSubTables := runtimehelper.GetPreloadsMap(ctx, "data").SubTables
	if len(preloadSubTables) > 0 {
		db = runtimehelper.GetPreloadSelection(ctx, db, preloadSubTables[0])
	}
	if filter != nil {
		blackList := make(map[string]struct{})
		sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(db, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
		db.Where(sql, arguments...)
	}
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	if order != nil {
		if order.Asc != nil {
			db = db.Order(fmt.Sprintf("%[1]s%[2]s%[1]s.%[1]s%[3]s%[1]s asc", runtimehelper.GetQuoteChar(db), tableName, order.Asc))
		}
		if order.Desc != nil {
			db = db.Order(fmt.Sprintf("%[1]s%[2]s%[1]s.%[1]s%[3]s%[1]s desc", runtimehelper.GetQuoteChar(db), tableName, order.Desc))
		}
	}
	var total int64
	db.Model(res).Count(&total)
	if first != nil {
		db = db.Limit(*first)
	}
	if offset != nil {
		db = db.Offset(*offset)
	}
	if len(group) > 0 {
		garr := make([]string, len(group))
		for i, g := range group {
			garr[i] = fmt.Sprintf("%s.%s", tableName, xstrings.ToSnakeCase(string(g)))
		}
		db = db.Group(strings.Join(garr, ","))
	}
	db = db.Find(&res)
	if okHook {
		var err error
		res, err = v.AfterCallDb(ctx, res)
		if err != nil {
			return nil, err
		}
		res, err = v.BeforeReturn(ctx, res, db)
		if err != nil {
			return nil, err
		}
	}
	return &model.SmartPhoneQueryResult{
		Data:       res,
		Count:      len(res),
		TotalCount: int(total),
	}, db.Error
}
func (r *Resolver) AddSmartPhonePayload() AddSmartPhonePayloadResolver {
	return &smartPhonePayloadResolver[*model.AddSmartPhonePayload]{r}
}
func (r *Resolver) DeleteSmartPhonePayload() DeleteSmartPhonePayloadResolver {
	return &smartPhonePayloadResolver[*model.DeleteSmartPhonePayload]{r}
}
func (r *Resolver) UpdateSmartPhonePayload() UpdateSmartPhonePayloadResolver {
	return &smartPhonePayloadResolver[*model.UpdateSmartPhonePayload]{r}
}

type smartPhonePayload interface {
	*model.AddSmartPhonePayload | *model.DeleteSmartPhonePayload | *model.UpdateSmartPhonePayload
}

type smartPhonePayloadResolver[T smartPhonePayload] struct {
	*Resolver
}

func (r *smartPhonePayloadResolver[T]) SmartPhone(ctx context.Context, obj T, filter *model.SmartPhoneFiltersInput, order *model.SmartPhoneOrder, first *int, offset *int, group []model.SmartPhoneGroup) (*model.SmartPhoneQueryResult, error) {
	q := r.Query().(*queryResolver)
	return q.QuerySmartPhone(ctx, filter, order, first, offset, group)
}

// AddSmartPhone is the resolver for the addSmartPhone field.
func (r *mutationResolver) AddSmartPhone(ctx context.Context, input []*model.SmartPhoneInput) (*model.AddSmartPhonePayload, error) {
	v, okHook := r.Sql.Hooks[string(db.AddSmartPhone)].(db.AutoGqlHookAdd[model.SmartPhone, model.SmartPhoneInput, model.AddSmartPhonePayload])
	res := &model.AddSmartPhonePayload{}
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, input)
		if err != nil {
			return nil, err
		}
	}
	obj := make([]model.SmartPhone, len(input))
	for i, v := range input {
		obj[i] = v.MergeToType()
	}
	db = db.Omit(clause.Associations)
	if okHook {
		var err error
		db, obj, err = v.BeforeCallDb(ctx, db, obj)
		if err != nil {
			return nil, err
		}
	}
	db = db.Create(&obj)
	affectedRes := make([]*model.SmartPhone, len(obj))
	for i, v := range obj {
		tmp := v
		affectedRes[i] = &tmp
	}
	res.Affected = affectedRes
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, obj, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// UpdateSmartPhone is the resolver for the updateSmartPhone field.
func (r *mutationResolver) UpdateSmartPhone(ctx context.Context, input model.UpdateSmartPhoneInput) (*model.UpdateSmartPhonePayload, error) {
	v, okHook := r.Sql.Hooks[string(db.UpdateSmartPhone)].(db.AutoGqlHookUpdate[model.UpdateSmartPhoneInput, model.UpdateSmartPhonePayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, &input)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("SmartPhone")
	blackList := make(map[string]struct{})
	queryDb := db.Select(tableName + ".id")
	sql, arguments := runtimehelper.CombineSimpleQuery(input.Filter.ExtendsDatabaseQuery(queryDb, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
	obj := model.SmartPhone{}
	queryDb = queryDb.Model(&obj).Where(sql, arguments...)
	var toChange []model.SmartPhone
	queryDb.Find(&toChange)
	update := input.Set.MergeToType()
	if okHook {
		var err error
		db, update, err = v.BeforeCallDb(ctx, db, update)
		if err != nil {
			return nil, err
		}
	}
	ids := make([]int, len(toChange))
	for i, one := range toChange {
		ids[i] = one.ID
	}
	db = db.Model(&obj).Where("id IN ?", ids).Updates(update)
	affectedRes := make([]*model.SmartPhone, 0)
	subTables := runtimehelper.GetPreloadsMap(ctx, "affected").SubTables
	if len(subTables) > 0 {
		if preloadMap := subTables[0]; len(preloadMap.Fields) > 0 {
			affectedDb := runtimehelper.GetPreloadSelection(ctx, db, preloadMap)
			affectedDb = affectedDb.Model(&obj)
			affectedDb.Find(&affectedRes)
		}
	}

	res := &model.UpdateSmartPhonePayload{
		Count:    int(db.RowsAffected),
		Affected: affectedRes,
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// DeleteSmartPhone is the resolver for the deleteSmartPhone field.
func (r *mutationResolver) DeleteSmartPhone(ctx context.Context, filter model.SmartPhoneFiltersInput) (*model.DeleteSmartPhonePayload, error) {
	v, okHook := r.Sql.Hooks[string(db.DeleteSmartPhone)].(db.AutoGqlHookDelete[model.SmartPhoneFiltersInput, model.DeleteSmartPhonePayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, err = v.Received(ctx, r.Sql, &filter)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("SmartPhone")
	blackList := make(map[string]struct{})
	queryDb := db.Select(tableName + ".id")
	sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(queryDb, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
	obj := model.SmartPhone{}
	queryDb = queryDb.Model(&obj).Where(sql, arguments...)
	var toChange []model.SmartPhone
	queryDb.Find(&toChange)
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	ids := make([]int, len(toChange))
	for i, one := range toChange {
		ids[i] = one.ID
	}
	db = db.Model(&obj).Where("id IN ?", ids).Delete(&obj)
	msg := fmt.Sprintf("%d rows deleted", db.RowsAffected)
	res := &model.DeleteSmartPhonePayload{
		Count: int(db.RowsAffected),
		Msg:   &msg,
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// GetTodo is the resolver for the getTodo field.
func (r *queryResolver) GetTodo(ctx context.Context, id int) (*model.Todo, error) {
	v, okHook := r.Sql.Hooks[string(db.GetTodo)].(db.AutoGqlHookGet[model.Todo, int])
	db := r.Sql.Db
	if okHook {
		var err error
		db, err = v.Received(ctx, r.Sql, id)
		if err != nil {
			return nil, err
		}
	}
	db = runtimehelper.GetPreloadSelection(ctx, db, runtimehelper.GetPreloadsMap(ctx, "Todo"))
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	var res model.Todo
	db = db.First(&res, "id = ?", id)
	if okHook {
		r, err := v.AfterCallDb(ctx, &res)
		if err != nil {
			return nil, err
		}
		res = *r
		r, err = v.BeforeReturn(ctx, &res, db)
		if err != nil {
			return nil, err
		}
		res = *r
	}
	return &res, db.Error
}

// QueryTodo is the resolver for the queryTodo field.
func (r *queryResolver) QueryTodo(ctx context.Context, filter *model.TodoFiltersInput, order *model.TodoOrder, first *int, offset *int, group []model.TodoGroup) (*model.TodoQueryResult, error) {
	v, okHook := r.Sql.Hooks[string(db.QueryTodo)].(db.AutoGqlHookQuery[model.Todo, model.TodoFiltersInput, model.TodoOrder])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, order, first, offset, err = v.Received(ctx, r.Sql, filter, order, first, offset)
		if err != nil {
			return nil, err
		}
	}
	var res []*model.Todo
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Todo")
	preloadSubTables := runtimehelper.GetPreloadsMap(ctx, "data").SubTables
	if len(preloadSubTables) > 0 {
		db = runtimehelper.GetPreloadSelection(ctx, db, preloadSubTables[0])
	}
	if filter != nil {
		blackList := make(map[string]struct{})
		sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(db, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
		db.Where(sql, arguments...)
	}
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	if order != nil {
		if order.Asc != nil {
			db = db.Order(fmt.Sprintf("%[1]s%[2]s%[1]s.%[1]s%[3]s%[1]s asc", runtimehelper.GetQuoteChar(db), tableName, order.Asc))
		}
		if order.Desc != nil {
			db = db.Order(fmt.Sprintf("%[1]s%[2]s%[1]s.%[1]s%[3]s%[1]s desc", runtimehelper.GetQuoteChar(db), tableName, order.Desc))
		}
	}
	var total int64
	db.Model(res).Count(&total)
	if first != nil {
		db = db.Limit(*first)
	}
	if offset != nil {
		db = db.Offset(*offset)
	}
	if len(group) > 0 {
		garr := make([]string, len(group))
		for i, g := range group {
			garr[i] = fmt.Sprintf("%s.%s", tableName, xstrings.ToSnakeCase(string(g)))
		}
		db = db.Group(strings.Join(garr, ","))
	}
	db = db.Find(&res)
	if okHook {
		var err error
		res, err = v.AfterCallDb(ctx, res)
		if err != nil {
			return nil, err
		}
		res, err = v.BeforeReturn(ctx, res, db)
		if err != nil {
			return nil, err
		}
	}
	return &model.TodoQueryResult{
		Data:       res,
		Count:      len(res),
		TotalCount: int(total),
	}, db.Error
}
func (r *Resolver) AddTodoPayload() AddTodoPayloadResolver {
	return &todoPayloadResolver[*model.AddTodoPayload]{r}
}
func (r *Resolver) DeleteTodoPayload() DeleteTodoPayloadResolver {
	return &todoPayloadResolver[*model.DeleteTodoPayload]{r}
}
func (r *Resolver) UpdateTodoPayload() UpdateTodoPayloadResolver {
	return &todoPayloadResolver[*model.UpdateTodoPayload]{r}
}

type todoPayload interface {
	*model.AddTodoPayload | *model.DeleteTodoPayload | *model.UpdateTodoPayload
}

type todoPayloadResolver[T todoPayload] struct {
	*Resolver
}

func (r *todoPayloadResolver[T]) Todo(ctx context.Context, obj T, filter *model.TodoFiltersInput, order *model.TodoOrder, first *int, offset *int, group []model.TodoGroup) (*model.TodoQueryResult, error) {
	q := r.Query().(*queryResolver)
	return q.QueryTodo(ctx, filter, order, first, offset, group)
}
func (r *mutationResolver) AddUser2Todos(ctx context.Context, input model.UserRef2TodosInput) (*model.UpdateTodoPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.AddUser2Todos)].(db.AutoGqlHookMany2ManyAdd[model.UserRef2TodosInput, model.UpdateTodoPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, &input)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Todo")
	blackList := make(map[string]struct{})
	sql, arguments := runtimehelper.CombineSimpleQuery(input.Filter.ExtendsDatabaseQuery(db, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
	db = db.Model(&model.Todo{}).Where(sql, arguments...)
	var res []*model.Todo
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	db.Find(&res)
	type TodoUsers struct {
		TodoID int
		UserID int
	}
	resIds := make([]map[string]interface{}, 0)
	for _, v := range res {
		for _, v1 := range input.Set {
			tmp := make(map[string]interface{})
			tmp["TodoID"] = v.ID
			tmp["UserID"] = v1
			resIds = append(resIds, tmp)
		}
	}
	d := r.Sql.Db.Model(&TodoUsers{}).Create(resIds)
	affectedRes := make([]*model.Todo, len(resIds))
	affectedResWhereIn := make([]interface{}, len(resIds))
	for i, v := range resIds {
		affectedResWhereIn[i] = v["TodoID"]
	}
	affectedDb := r.Sql.Db
	subTables := runtimehelper.GetPreloadsMap(ctx, "affected").SubTables
	if len(subTables) > 0 {
		if preloadMap := subTables[0]; len(preloadMap.Fields) > 0 {
			affectedDb = runtimehelper.GetPreloadSelection(ctx, affectedDb, preloadMap)
			affectedDb.Where("id IN ?", affectedResWhereIn).Find(&affectedRes)
		}
	}
	result := &model.UpdateTodoPayload{
		Affected: affectedRes,
		Count:    int(d.RowsAffected),
	}
	if okHook {
		var err error
		result, err = v.BeforeReturn(ctx, db, result)
		if err != nil {
			return nil, err
		}
	}
	return result, d.Error
}

func (r *mutationResolver) DeleteUserFromTodos(ctx context.Context, input model.UserRef2TodosInput) (*model.DeleteTodoPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.DeleteUserFromTodos)].(db.AutoGqlHookMany2ManyDelete[model.UserRef2TodosInput, model.DeleteTodoPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, &input)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Todo")
	blackList := make(map[string]struct{})
	sql, arguments := runtimehelper.CombineSimpleQuery(input.Filter.ExtendsDatabaseQuery(db, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
	db = db.Model(&model.Todo{}).Where(sql, arguments...)
	var res []*model.Todo
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	db.Find(&res)
	type TodoUsers struct {
		TodoID int
		UserID int
	}
	resIds := make([]TodoUsers, 0)
	for _, v := range res {
		for _, v1 := range input.Set {
			resIds = append(resIds, TodoUsers{
				TodoID: v.ID,
				UserID: v1,
			})
		}
	}
	rowsAffected := 0
	for _, v := range resIds {
		d := r.Sql.Db.Model(&TodoUsers{}).Where(v).Delete(v)
		rowsAffected += int(d.RowsAffected)
		if d.Error != nil {
			graphql.AddError(ctx, d.Error)
		}
	}
	msg := fmt.Sprintf("%d rows deleted", db.RowsAffected)
	result := &model.DeleteTodoPayload{
		Count: rowsAffected,
		Msg:   &msg,
	}
	if okHook {
		var err error
		result, err = v.BeforeReturn(ctx, db, result)
		if err != nil {
			return nil, err
		}
	}
	return result, nil
}

// AddTodo is the resolver for the addTodo field.
func (r *mutationResolver) AddTodo(ctx context.Context, input []*model.TodoInput) (*model.AddTodoPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.AddTodo)].(db.AutoGqlHookAdd[model.Todo, model.TodoInput, model.AddTodoPayload])
	res := &model.AddTodoPayload{}
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, input)
		if err != nil {
			return nil, err
		}
	}
	obj := make([]model.Todo, len(input))
	for i, v := range input {
		obj[i] = v.MergeToType()
	}
	db = db.Omit(clause.Associations)
	if okHook {
		var err error
		db, obj, err = v.BeforeCallDb(ctx, db, obj)
		if err != nil {
			return nil, err
		}
	}
	db = db.Create(&obj)
	affectedRes := make([]*model.Todo, len(obj))
	for i, v := range obj {
		tmp := v
		affectedRes[i] = &tmp
	}
	res.Affected = affectedRes
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, obj, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// UpdateTodo is the resolver for the updateTodo field.
func (r *mutationResolver) UpdateTodo(ctx context.Context, input model.UpdateTodoInput) (*model.UpdateTodoPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.UpdateTodo)].(db.AutoGqlHookUpdate[model.UpdateTodoInput, model.UpdateTodoPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, &input)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Todo")
	blackList := make(map[string]struct{})
	queryDb := db.Select(tableName + ".id")
	sql, arguments := runtimehelper.CombineSimpleQuery(input.Filter.ExtendsDatabaseQuery(queryDb, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
	obj := model.Todo{}
	queryDb = queryDb.Model(&obj).Where(sql, arguments...)
	var toChange []model.Todo
	queryDb.Find(&toChange)
	update := input.Set.MergeToType()
	if okHook {
		var err error
		db, update, err = v.BeforeCallDb(ctx, db, update)
		if err != nil {
			return nil, err
		}
	}
	ids := make([]int, len(toChange))
	for i, one := range toChange {
		ids[i] = one.ID
	}
	db = db.Model(&obj).Where("id IN ?", ids).Updates(update)
	affectedRes := make([]*model.Todo, 0)
	subTables := runtimehelper.GetPreloadsMap(ctx, "affected").SubTables
	if len(subTables) > 0 {
		if preloadMap := subTables[0]; len(preloadMap.Fields) > 0 {
			affectedDb := runtimehelper.GetPreloadSelection(ctx, db, preloadMap)
			affectedDb = affectedDb.Model(&obj)
			affectedDb.Find(&affectedRes)
		}
	}

	res := &model.UpdateTodoPayload{
		Count:    int(db.RowsAffected),
		Affected: affectedRes,
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// DeleteTodo is the resolver for the deleteTodo field.
func (r *mutationResolver) DeleteTodo(ctx context.Context, filter model.TodoFiltersInput) (*model.DeleteTodoPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.DeleteTodo)].(db.AutoGqlHookDelete[model.TodoFiltersInput, model.DeleteTodoPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, err = v.Received(ctx, r.Sql, &filter)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Todo")
	blackList := make(map[string]struct{})
	queryDb := db.Select(tableName + ".id")
	sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(queryDb, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
	obj := model.Todo{}
	queryDb = queryDb.Model(&obj).Where(sql, arguments...)
	var toChange []model.Todo
	queryDb.Find(&toChange)
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	ids := make([]int, len(toChange))
	for i, one := range toChange {
		ids[i] = one.ID
	}
	db = db.Model(&obj).Where("id IN ?", ids).Delete(&obj)
	msg := fmt.Sprintf("%d rows deleted", db.RowsAffected)
	res := &model.DeleteTodoPayload{
		Count: int(db.RowsAffected),
		Msg:   &msg,
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// GetUser is the resolver for the getUser field.
func (r *queryResolver) GetUser(ctx context.Context, id int) (*model.User, error) {
	v, okHook := r.Sql.Hooks[string(db.GetUser)].(db.AutoGqlHookGet[model.User, int])
	db := r.Sql.Db
	if okHook {
		var err error
		db, err = v.Received(ctx, r.Sql, id)
		if err != nil {
			return nil, err
		}
	}
	db = runtimehelper.GetPreloadSelection(ctx, db, runtimehelper.GetPreloadsMap(ctx, "User"))
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	var res model.User
	db = db.First(&res, "id = ?", id)
	if okHook {
		r, err := v.AfterCallDb(ctx, &res)
		if err != nil {
			return nil, err
		}
		res = *r
		r, err = v.BeforeReturn(ctx, &res, db)
		if err != nil {
			return nil, err
		}
		res = *r
	}
	return &res, db.Error
}

// QueryUser is the resolver for the queryUser field.
func (r *queryResolver) QueryUser(ctx context.Context, filter *model.UserFiltersInput, order *model.UserOrder, first *int, offset *int, group []model.UserGroup) (*model.UserQueryResult, error) {
	v, okHook := r.Sql.Hooks[string(db.QueryUser)].(db.AutoGqlHookQuery[model.User, model.UserFiltersInput, model.UserOrder])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, order, first, offset, err = v.Received(ctx, r.Sql, filter, order, first, offset)
		if err != nil {
			return nil, err
		}
	}
	var res []*model.User
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("User")
	preloadSubTables := runtimehelper.GetPreloadsMap(ctx, "data").SubTables
	if len(preloadSubTables) > 0 {
		db = runtimehelper.GetPreloadSelection(ctx, db, preloadSubTables[0])
	}
	if filter != nil {
		blackList := make(map[string]struct{})
		sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(db, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
		db.Where(sql, arguments...)
	}
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	if order != nil {
		if order.Asc != nil {
			db = db.Order(fmt.Sprintf("%[1]s%[2]s%[1]s.%[1]s%[3]s%[1]s asc", runtimehelper.GetQuoteChar(db), tableName, order.Asc))
		}
		if order.Desc != nil {
			db = db.Order(fmt.Sprintf("%[1]s%[2]s%[1]s.%[1]s%[3]s%[1]s desc", runtimehelper.GetQuoteChar(db), tableName, order.Desc))
		}
	}
	var total int64
	db.Model(res).Count(&total)
	if first != nil {
		db = db.Limit(*first)
	}
	if offset != nil {
		db = db.Offset(*offset)
	}
	if len(group) > 0 {
		garr := make([]string, len(group))
		for i, g := range group {
			garr[i] = fmt.Sprintf("%s.%s", tableName, xstrings.ToSnakeCase(string(g)))
		}
		db = db.Group(strings.Join(garr, ","))
	}
	db = db.Find(&res)
	if okHook {
		var err error
		res, err = v.AfterCallDb(ctx, res)
		if err != nil {
			return nil, err
		}
		res, err = v.BeforeReturn(ctx, res, db)
		if err != nil {
			return nil, err
		}
	}
	return &model.UserQueryResult{
		Data:       res,
		Count:      len(res),
		TotalCount: int(total),
	}, db.Error
}
func (r *Resolver) AddUserPayload() AddUserPayloadResolver {
	return &userPayloadResolver[*model.AddUserPayload]{r}
}
func (r *Resolver) DeleteUserPayload() DeleteUserPayloadResolver {
	return &userPayloadResolver[*model.DeleteUserPayload]{r}
}
func (r *Resolver) UpdateUserPayload() UpdateUserPayloadResolver {
	return &userPayloadResolver[*model.UpdateUserPayload]{r}
}

type userPayload interface {
	*model.AddUserPayload | *model.DeleteUserPayload | *model.UpdateUserPayload
}

type userPayloadResolver[T userPayload] struct {
	*Resolver
}

func (r *userPayloadResolver[T]) User(ctx context.Context, obj T, filter *model.UserFiltersInput, order *model.UserOrder, first *int, offset *int, group []model.UserGroup) (*model.UserQueryResult, error) {
	q := r.Query().(*queryResolver)
	return q.QueryUser(ctx, filter, order, first, offset, group)
}

// AddUser is the resolver for the addUser field.
func (r *mutationResolver) AddUser(ctx context.Context, input []*model.UserInput) (*model.AddUserPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.AddUser)].(db.AutoGqlHookAdd[model.User, model.UserInput, model.AddUserPayload])
	res := &model.AddUserPayload{}
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, input)
		if err != nil {
			return nil, err
		}
	}
	obj := make([]model.User, len(input))
	for i, v := range input {
		obj[i] = v.MergeToType()
	}
	db = db.Omit(clause.Associations)
	if okHook {
		var err error
		db, obj, err = v.BeforeCallDb(ctx, db, obj)
		if err != nil {
			return nil, err
		}
	}
	db = db.Create(&obj)
	affectedRes := make([]*model.User, len(obj))
	for i, v := range obj {
		tmp := v
		affectedRes[i] = &tmp
	}
	res.Affected = affectedRes
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, obj, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model.UpdateUserInput) (*model.UpdateUserPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.UpdateUser)].(db.AutoGqlHookUpdate[model.UpdateUserInput, model.UpdateUserPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, &input)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("User")
	blackList := make(map[string]struct{})
	queryDb := db.Select(tableName + ".id")
	sql, arguments := runtimehelper.CombineSimpleQuery(input.Filter.ExtendsDatabaseQuery(queryDb, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
	obj := model.User{}
	queryDb = queryDb.Model(&obj).Where(sql, arguments...)
	var toChange []model.User
	queryDb.Find(&toChange)
	update := input.Set.MergeToType()
	if okHook {
		var err error
		db, update, err = v.BeforeCallDb(ctx, db, update)
		if err != nil {
			return nil, err
		}
	}
	ids := make([]int, len(toChange))
	for i, one := range toChange {
		ids[i] = one.ID
	}
	db = db.Model(&obj).Where("id IN ?", ids).Updates(update)
	affectedRes := make([]*model.User, 0)
	subTables := runtimehelper.GetPreloadsMap(ctx, "affected").SubTables
	if len(subTables) > 0 {
		if preloadMap := subTables[0]; len(preloadMap.Fields) > 0 {
			affectedDb := runtimehelper.GetPreloadSelection(ctx, db, preloadMap)
			affectedDb = affectedDb.Model(&obj)
			affectedDb.Find(&affectedRes)
		}
	}

	res := &model.UpdateUserPayload{
		Count:    int(db.RowsAffected),
		Affected: affectedRes,
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, filter model.UserFiltersInput) (*model.DeleteUserPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.DeleteUser)].(db.AutoGqlHookDelete[model.UserFiltersInput, model.DeleteUserPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, err = v.Received(ctx, r.Sql, &filter)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("User")
	blackList := make(map[string]struct{})
	queryDb := db.Select(tableName + ".id")
	sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(queryDb, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
	obj := model.User{}
	queryDb = queryDb.Model(&obj).Where(sql, arguments...)
	var toChange []model.User
	queryDb.Find(&toChange)
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	ids := make([]int, len(toChange))
	for i, one := range toChange {
		ids[i] = one.ID
	}
	db = db.Model(&obj).Where("id IN ?", ids).Delete(&obj)
	msg := fmt.Sprintf("%d rows deleted", db.RowsAffected)
	res := &model.DeleteUserPayload{
		Count: int(db.RowsAffected),
		Msg:   &msg,
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}
