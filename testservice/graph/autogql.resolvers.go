// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"context"
	"fmt"

	"github.com/fasibio/autogql/runtimehelper"
	"github.com/fasibio/autogql/testservice/graph/db"
	"github.com/fasibio/autogql/testservice/graph/model"
	"gorm.io/gorm/clause"
)

// GetCat is the resolver for the getCat field.
func (r *queryResolver) GetCat(ctx context.Context, id int) (*model.Cat, error) {
	v, okHook := r.Sql.Hooks[string(db.GetCat)].(db.AutoGqlHookGet[model.Cat, int])
	db := r.Sql.Db
	if okHook {
		var err error
		db, err = v.Received(ctx, r.Sql, id)
		if err != nil {
			return nil, err
		}
	}
	db = runtimehelper.GetPreloadSelection(ctx, db, runtimehelper.GetPreloadsMap(ctx, "Cat"))
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	var res model.Cat
	db = db.First(&res, id)
	if okHook {
		r, err := v.AfterCallDb(ctx, &res)
		if err != nil {
			return nil, err
		}
		res = *r
		r, err = v.BeforeReturn(ctx, &res, db)
		if err != nil {
			return nil, err
		}
		res = *r
	}
	return &res, db.Error
}

// QueryCat is the resolver for the queryCat field.
func (r *queryResolver) QueryCat(ctx context.Context, filter *model.CatFiltersInput, order *model.CatOrder, first *int, offset *int) (*model.CatQueryResult, error) {
	v, okHook := r.Sql.Hooks[string(db.QueryCat)].(db.AutoGqlHookQuery[model.Cat, model.CatFiltersInput, model.CatOrder])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, order, first, offset, err = v.Received(ctx, r.Sql, filter, order, first, offset)
		if err != nil {
			return nil, err
		}
	}
	var res []*model.Cat
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Cat")
	db = runtimehelper.GetPreloadSelection(ctx, db, runtimehelper.GetPreloadsMap(ctx, "data").SubTables[0])
	if filter != nil {
		blackList := make(map[string]struct{})
		sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(db, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
		db.Where(sql, arguments...)
	}

	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}

	if order != nil {
		if order.Asc != nil {
			db = db.Order(fmt.Sprintf("%[1]s%[2]s%[1]s.%[1]s%[3]s%[1]s asc", runtimehelper.GetQuoteChar(db), tableName, order.Asc))
		}
		if order.Desc != nil {
			db = db.Order(fmt.Sprintf("%[1]s%[2]s%[1]s.%[1]s%[3]s%[1]s desc", runtimehelper.GetQuoteChar(db), tableName, order.Desc))
		}
	}
	var total int64
	db.Model(res).Count(&total)
	if first != nil {
		db = db.Limit(*first)
	}
	if offset != nil {
		db = db.Offset(*offset)
	}
	db = db.Find(&res)
	if okHook {
		var err error
		res, err = v.AfterCallDb(ctx, res)
		if err != nil {
			return nil, err
		}
		res, err = v.BeforeReturn(ctx, res, db)
		if err != nil {
			return nil, err
		}
	}
	return &model.CatQueryResult{
		Data:       res,
		Count:      len(res),
		TotalCount: int(total),
	}, db.Error
}
func (r *Resolver) AddCatPayload() AddCatPayloadResolver {
	return &catPayloadResolver[*model.AddCatPayload]{r}
}
func (r *Resolver) DeleteCatPayload() DeleteCatPayloadResolver {
	return &catPayloadResolver[*model.DeleteCatPayload]{r}
}
func (r *Resolver) UpdateCatPayload() UpdateCatPayloadResolver {
	return &catPayloadResolver[*model.UpdateCatPayload]{r}
}

type catPayload interface {
	*model.AddCatPayload | *model.DeleteCatPayload | *model.UpdateCatPayload
}

type catPayloadResolver[T catPayload] struct {
	*Resolver
}

func (r *catPayloadResolver[T]) Cat(ctx context.Context, obj T, filter *model.CatFiltersInput, order *model.CatOrder, first *int, offset *int) (*model.CatQueryResult, error) {
	return r.Query().QueryCat(ctx, filter, order, first, offset)
}

// AddCat is the resolver for the addCat field.
func (r *mutationResolver) AddCat(ctx context.Context, input []*model.CatInput) (*model.AddCatPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.AddCat)].(db.AutoGqlHookAdd[model.Cat, model.CatInput, model.AddCatPayload])
	res := &model.AddCatPayload{}
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, input)
		if err != nil {
			return nil, err
		}
	}
	obj := make([]model.Cat, len(input))
	for i, v := range input {
		obj[i] = v.MergeToType()
	}
	db = db.Omit(clause.Associations)
	if okHook {
		var err error
		db, obj, err = v.BeforeCallDb(ctx, db, obj)
		if err != nil {
			return nil, err
		}
	}
	db = db.Create(&obj)
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, obj, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// UpdateCat is the resolver for the updateCat field.
func (r *mutationResolver) UpdateCat(ctx context.Context, input model.UpdateCatInput) (*model.UpdateCatPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.UpdateCat)].(db.AutoGqlHookUpdate[model.UpdateCatInput, model.UpdateCatPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, &input)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Cat")
	blackList := make(map[string]struct{})
	queryDb := db.Select(tableName + ".id")
	sql, arguments := runtimehelper.CombineSimpleQuery(input.Filter.ExtendsDatabaseQuery(queryDb, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
	obj := model.Cat{}
	queryDb = queryDb.Model(&obj).Where(sql, arguments...)
	var toChange []model.Cat
	queryDb.Find(&toChange)
	update := input.Set.MergeToType()
	if okHook {
		var err error
		db, update, err = v.BeforeCallDb(ctx, db, update)
		if err != nil {
			return nil, err
		}
	}
	ids := make([]int, len(toChange))
	for i, one := range toChange {
		ids[i] = one.ID
	}
	db = db.Model(&obj).Where("id IN ?", ids).Updates(update)
	res := &model.UpdateCatPayload{
		Count: int(db.RowsAffected),
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// DeleteCat is the resolver for the deleteCat field.
func (r *mutationResolver) DeleteCat(ctx context.Context, filter model.CatFiltersInput) (*model.DeleteCatPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.DeleteCat)].(db.AutoGqlHookDelete[model.CatFiltersInput, model.DeleteCatPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, err = v.Received(ctx, r.Sql, &filter)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Cat")
	blackList := make(map[string]struct{})
	queryDb := db.Select(tableName + ".id")
	sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(queryDb, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
	obj := model.Cat{}
	queryDb = queryDb.Model(&obj).Where(sql, arguments...)
	var toChange []model.Cat
	queryDb.Find(&toChange)
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	ids := make([]int, len(toChange))
	for i, one := range toChange {
		ids[i] = one.ID
	}
	db = db.Model(&obj).Where("id IN ?", ids).Delete(&obj)
	msg := fmt.Sprintf("%d rows deleted", db.RowsAffected)
	res := &model.DeleteCatPayload{
		Count: int(db.RowsAffected),
		Msg:   &msg,
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// GetCompany is the resolver for the getCompany field.
func (r *queryResolver) GetCompany(ctx context.Context, id int) (*model.Company, error) {
	v, okHook := r.Sql.Hooks[string(db.GetCompany)].(db.AutoGqlHookGet[model.Company, int])
	db := r.Sql.Db
	if okHook {
		var err error
		db, err = v.Received(ctx, r.Sql, id)
		if err != nil {
			return nil, err
		}
	}
	db = runtimehelper.GetPreloadSelection(ctx, db, runtimehelper.GetPreloadsMap(ctx, "Company"))
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	var res model.Company
	db = db.First(&res, id)
	if okHook {
		r, err := v.AfterCallDb(ctx, &res)
		if err != nil {
			return nil, err
		}
		res = *r
		r, err = v.BeforeReturn(ctx, &res, db)
		if err != nil {
			return nil, err
		}
		res = *r
	}
	return &res, db.Error
}

// QueryCompany is the resolver for the queryCompany field.
func (r *queryResolver) QueryCompany(ctx context.Context, filter *model.CompanyFiltersInput, order *model.CompanyOrder, first *int, offset *int) (*model.CompanyQueryResult, error) {
	v, okHook := r.Sql.Hooks[string(db.QueryCompany)].(db.AutoGqlHookQuery[model.Company, model.CompanyFiltersInput, model.CompanyOrder])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, order, first, offset, err = v.Received(ctx, r.Sql, filter, order, first, offset)
		if err != nil {
			return nil, err
		}
	}
	var res []*model.Company
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Company")
	db = runtimehelper.GetPreloadSelection(ctx, db, runtimehelper.GetPreloadsMap(ctx, "data").SubTables[0])
	if filter != nil {
		blackList := make(map[string]struct{})
		sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(db, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
		db.Where(sql, arguments...)
	}

	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}

	if order != nil {
		if order.Asc != nil {
			db = db.Order(fmt.Sprintf("%[1]s%[2]s%[1]s.%[1]s%[3]s%[1]s asc", runtimehelper.GetQuoteChar(db), tableName, order.Asc))
		}
		if order.Desc != nil {
			db = db.Order(fmt.Sprintf("%[1]s%[2]s%[1]s.%[1]s%[3]s%[1]s desc", runtimehelper.GetQuoteChar(db), tableName, order.Desc))
		}
	}
	var total int64
	db.Model(res).Count(&total)
	if first != nil {
		db = db.Limit(*first)
	}
	if offset != nil {
		db = db.Offset(*offset)
	}
	db = db.Find(&res)
	if okHook {
		var err error
		res, err = v.AfterCallDb(ctx, res)
		if err != nil {
			return nil, err
		}
		res, err = v.BeforeReturn(ctx, res, db)
		if err != nil {
			return nil, err
		}
	}
	return &model.CompanyQueryResult{
		Data:       res,
		Count:      len(res),
		TotalCount: int(total),
	}, db.Error
}
func (r *Resolver) AddCompanyPayload() AddCompanyPayloadResolver {
	return &companyPayloadResolver[*model.AddCompanyPayload]{r}
}
func (r *Resolver) DeleteCompanyPayload() DeleteCompanyPayloadResolver {
	return &companyPayloadResolver[*model.DeleteCompanyPayload]{r}
}
func (r *Resolver) UpdateCompanyPayload() UpdateCompanyPayloadResolver {
	return &companyPayloadResolver[*model.UpdateCompanyPayload]{r}
}

type companyPayload interface {
	*model.AddCompanyPayload | *model.DeleteCompanyPayload | *model.UpdateCompanyPayload
}

type companyPayloadResolver[T companyPayload] struct {
	*Resolver
}

func (r *companyPayloadResolver[T]) Company(ctx context.Context, obj T, filter *model.CompanyFiltersInput, order *model.CompanyOrder, first *int, offset *int) (*model.CompanyQueryResult, error) {
	return r.Query().QueryCompany(ctx, filter, order, first, offset)
}

// AddCompany is the resolver for the addCompany field.
func (r *mutationResolver) AddCompany(ctx context.Context, input []*model.CompanyInput) (*model.AddCompanyPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.AddCompany)].(db.AutoGqlHookAdd[model.Company, model.CompanyInput, model.AddCompanyPayload])
	res := &model.AddCompanyPayload{}
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, input)
		if err != nil {
			return nil, err
		}
	}
	obj := make([]model.Company, len(input))
	for i, v := range input {
		obj[i] = v.MergeToType()
	}
	db = db.Omit(clause.Associations)
	if okHook {
		var err error
		db, obj, err = v.BeforeCallDb(ctx, db, obj)
		if err != nil {
			return nil, err
		}
	}
	db = db.Create(&obj)
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, obj, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// UpdateCompany is the resolver for the updateCompany field.
func (r *mutationResolver) UpdateCompany(ctx context.Context, input model.UpdateCompanyInput) (*model.UpdateCompanyPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.UpdateCompany)].(db.AutoGqlHookUpdate[model.UpdateCompanyInput, model.UpdateCompanyPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, &input)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Company")
	blackList := make(map[string]struct{})
	queryDb := db.Select(tableName + ".id")
	sql, arguments := runtimehelper.CombineSimpleQuery(input.Filter.ExtendsDatabaseQuery(queryDb, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
	obj := model.Company{}
	queryDb = queryDb.Model(&obj).Where(sql, arguments...)
	var toChange []model.Company
	queryDb.Find(&toChange)
	update := input.Set.MergeToType()
	if okHook {
		var err error
		db, update, err = v.BeforeCallDb(ctx, db, update)
		if err != nil {
			return nil, err
		}
	}
	ids := make([]int, len(toChange))
	for i, one := range toChange {
		ids[i] = one.ID
	}
	db = db.Model(&obj).Where("id IN ?", ids).Updates(update)
	res := &model.UpdateCompanyPayload{
		Count: int(db.RowsAffected),
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// DeleteCompany is the resolver for the deleteCompany field.
func (r *mutationResolver) DeleteCompany(ctx context.Context, filter model.CompanyFiltersInput) (*model.DeleteCompanyPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.DeleteCompany)].(db.AutoGqlHookDelete[model.CompanyFiltersInput, model.DeleteCompanyPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, err = v.Received(ctx, r.Sql, &filter)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Company")
	blackList := make(map[string]struct{})
	queryDb := db.Select(tableName + ".id")
	sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(queryDb, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
	obj := model.Company{}
	queryDb = queryDb.Model(&obj).Where(sql, arguments...)
	var toChange []model.Company
	queryDb.Find(&toChange)
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	ids := make([]int, len(toChange))
	for i, one := range toChange {
		ids[i] = one.ID
	}
	db = db.Model(&obj).Where("id IN ?", ids).Delete(&obj)
	msg := fmt.Sprintf("%d rows deleted", db.RowsAffected)
	res := &model.DeleteCompanyPayload{
		Count: int(db.RowsAffected),
		Msg:   &msg,
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// GetSmartPhone is the resolver for the getSmartPhone field.
func (r *queryResolver) GetSmartPhone(ctx context.Context, id int) (*model.SmartPhone, error) {
	v, okHook := r.Sql.Hooks[string(db.GetSmartPhone)].(db.AutoGqlHookGet[model.SmartPhone, int])
	db := r.Sql.Db
	if okHook {
		var err error
		db, err = v.Received(ctx, r.Sql, id)
		if err != nil {
			return nil, err
		}
	}
	db = runtimehelper.GetPreloadSelection(ctx, db, runtimehelper.GetPreloadsMap(ctx, "SmartPhone"))
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	var res model.SmartPhone
	db = db.First(&res, id)
	if okHook {
		r, err := v.AfterCallDb(ctx, &res)
		if err != nil {
			return nil, err
		}
		res = *r
		r, err = v.BeforeReturn(ctx, &res, db)
		if err != nil {
			return nil, err
		}
		res = *r
	}
	return &res, db.Error
}

// QuerySmartPhone is the resolver for the querySmartPhone field.
func (r *queryResolver) QuerySmartPhone(ctx context.Context, filter *model.SmartPhoneFiltersInput, order *model.SmartPhoneOrder, first *int, offset *int) (*model.SmartPhoneQueryResult, error) {
	v, okHook := r.Sql.Hooks[string(db.QuerySmartPhone)].(db.AutoGqlHookQuery[model.SmartPhone, model.SmartPhoneFiltersInput, model.SmartPhoneOrder])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, order, first, offset, err = v.Received(ctx, r.Sql, filter, order, first, offset)
		if err != nil {
			return nil, err
		}
	}
	var res []*model.SmartPhone
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("SmartPhone")
	db = runtimehelper.GetPreloadSelection(ctx, db, runtimehelper.GetPreloadsMap(ctx, "data").SubTables[0])
	if filter != nil {
		blackList := make(map[string]struct{})
		sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(db, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
		db.Where(sql, arguments...)
	}

	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}

	if order != nil {
		if order.Asc != nil {
			db = db.Order(fmt.Sprintf("%[1]s%[2]s%[1]s.%[1]s%[3]s%[1]s asc", runtimehelper.GetQuoteChar(db), tableName, order.Asc))
		}
		if order.Desc != nil {
			db = db.Order(fmt.Sprintf("%[1]s%[2]s%[1]s.%[1]s%[3]s%[1]s desc", runtimehelper.GetQuoteChar(db), tableName, order.Desc))
		}
	}
	var total int64
	db.Model(res).Count(&total)
	if first != nil {
		db = db.Limit(*first)
	}
	if offset != nil {
		db = db.Offset(*offset)
	}
	db = db.Find(&res)
	if okHook {
		var err error
		res, err = v.AfterCallDb(ctx, res)
		if err != nil {
			return nil, err
		}
		res, err = v.BeforeReturn(ctx, res, db)
		if err != nil {
			return nil, err
		}
	}
	return &model.SmartPhoneQueryResult{
		Data:       res,
		Count:      len(res),
		TotalCount: int(total),
	}, db.Error
}
func (r *Resolver) AddSmartPhonePayload() AddSmartPhonePayloadResolver {
	return &smartPhonePayloadResolver[*model.AddSmartPhonePayload]{r}
}
func (r *Resolver) DeleteSmartPhonePayload() DeleteSmartPhonePayloadResolver {
	return &smartPhonePayloadResolver[*model.DeleteSmartPhonePayload]{r}
}
func (r *Resolver) UpdateSmartPhonePayload() UpdateSmartPhonePayloadResolver {
	return &smartPhonePayloadResolver[*model.UpdateSmartPhonePayload]{r}
}

type smartPhonePayload interface {
	*model.AddSmartPhonePayload | *model.DeleteSmartPhonePayload | *model.UpdateSmartPhonePayload
}

type smartPhonePayloadResolver[T smartPhonePayload] struct {
	*Resolver
}

func (r *smartPhonePayloadResolver[T]) SmartPhone(ctx context.Context, obj T, filter *model.SmartPhoneFiltersInput, order *model.SmartPhoneOrder, first *int, offset *int) (*model.SmartPhoneQueryResult, error) {
	return r.Query().QuerySmartPhone(ctx, filter, order, first, offset)
}

// AddSmartPhone is the resolver for the addSmartPhone field.
func (r *mutationResolver) AddSmartPhone(ctx context.Context, input []*model.SmartPhoneInput) (*model.AddSmartPhonePayload, error) {
	v, okHook := r.Sql.Hooks[string(db.AddSmartPhone)].(db.AutoGqlHookAdd[model.SmartPhone, model.SmartPhoneInput, model.AddSmartPhonePayload])
	res := &model.AddSmartPhonePayload{}
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, input)
		if err != nil {
			return nil, err
		}
	}
	obj := make([]model.SmartPhone, len(input))
	for i, v := range input {
		obj[i] = v.MergeToType()
	}
	db = db.Omit(clause.Associations)
	if okHook {
		var err error
		db, obj, err = v.BeforeCallDb(ctx, db, obj)
		if err != nil {
			return nil, err
		}
	}
	db = db.Create(&obj)
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, obj, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// UpdateSmartPhone is the resolver for the updateSmartPhone field.
func (r *mutationResolver) UpdateSmartPhone(ctx context.Context, input model.UpdateSmartPhoneInput) (*model.UpdateSmartPhonePayload, error) {
	v, okHook := r.Sql.Hooks[string(db.UpdateSmartPhone)].(db.AutoGqlHookUpdate[model.UpdateSmartPhoneInput, model.UpdateSmartPhonePayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, &input)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("SmartPhone")
	blackList := make(map[string]struct{})
	queryDb := db.Select(tableName + ".id")
	sql, arguments := runtimehelper.CombineSimpleQuery(input.Filter.ExtendsDatabaseQuery(queryDb, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
	obj := model.SmartPhone{}
	queryDb = queryDb.Model(&obj).Where(sql, arguments...)
	var toChange []model.SmartPhone
	queryDb.Find(&toChange)
	update := input.Set.MergeToType()
	if okHook {
		var err error
		db, update, err = v.BeforeCallDb(ctx, db, update)
		if err != nil {
			return nil, err
		}
	}
	ids := make([]int, len(toChange))
	for i, one := range toChange {
		ids[i] = one.ID
	}
	db = db.Model(&obj).Where("id IN ?", ids).Updates(update)
	res := &model.UpdateSmartPhonePayload{
		Count: int(db.RowsAffected),
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// DeleteSmartPhone is the resolver for the deleteSmartPhone field.
func (r *mutationResolver) DeleteSmartPhone(ctx context.Context, filter model.SmartPhoneFiltersInput) (*model.DeleteSmartPhonePayload, error) {
	v, okHook := r.Sql.Hooks[string(db.DeleteSmartPhone)].(db.AutoGqlHookDelete[model.SmartPhoneFiltersInput, model.DeleteSmartPhonePayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, err = v.Received(ctx, r.Sql, &filter)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("SmartPhone")
	blackList := make(map[string]struct{})
	queryDb := db.Select(tableName + ".id")
	sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(queryDb, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
	obj := model.SmartPhone{}
	queryDb = queryDb.Model(&obj).Where(sql, arguments...)
	var toChange []model.SmartPhone
	queryDb.Find(&toChange)
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	ids := make([]int, len(toChange))
	for i, one := range toChange {
		ids[i] = one.ID
	}
	db = db.Model(&obj).Where("id IN ?", ids).Delete(&obj)
	msg := fmt.Sprintf("%d rows deleted", db.RowsAffected)
	res := &model.DeleteSmartPhonePayload{
		Count: int(db.RowsAffected),
		Msg:   &msg,
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// GetTodo is the resolver for the getTodo field.
func (r *queryResolver) GetTodo(ctx context.Context, id int) (*model.Todo, error) {
	v, okHook := r.Sql.Hooks[string(db.GetTodo)].(db.AutoGqlHookGet[model.Todo, int])
	db := r.Sql.Db
	if okHook {
		var err error
		db, err = v.Received(ctx, r.Sql, id)
		if err != nil {
			return nil, err
		}
	}
	db = runtimehelper.GetPreloadSelection(ctx, db, runtimehelper.GetPreloadsMap(ctx, "Todo"))
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	var res model.Todo
	db = db.First(&res, id)
	if okHook {
		r, err := v.AfterCallDb(ctx, &res)
		if err != nil {
			return nil, err
		}
		res = *r
		r, err = v.BeforeReturn(ctx, &res, db)
		if err != nil {
			return nil, err
		}
		res = *r
	}
	return &res, db.Error
}

// QueryTodo is the resolver for the queryTodo field.
func (r *queryResolver) QueryTodo(ctx context.Context, filter *model.TodoFiltersInput, order *model.TodoOrder, first *int, offset *int) (*model.TodoQueryResult, error) {
	v, okHook := r.Sql.Hooks[string(db.QueryTodo)].(db.AutoGqlHookQuery[model.Todo, model.TodoFiltersInput, model.TodoOrder])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, order, first, offset, err = v.Received(ctx, r.Sql, filter, order, first, offset)
		if err != nil {
			return nil, err
		}
	}
	var res []*model.Todo
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Todo")
	db = runtimehelper.GetPreloadSelection(ctx, db, runtimehelper.GetPreloadsMap(ctx, "data").SubTables[0])
	if filter != nil {
		blackList := make(map[string]struct{})
		sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(db, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
		db.Where(sql, arguments...)
	}

	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}

	if order != nil {
		if order.Asc != nil {
			db = db.Order(fmt.Sprintf("%[1]s%[2]s%[1]s.%[1]s%[3]s%[1]s asc", runtimehelper.GetQuoteChar(db), tableName, order.Asc))
		}
		if order.Desc != nil {
			db = db.Order(fmt.Sprintf("%[1]s%[2]s%[1]s.%[1]s%[3]s%[1]s desc", runtimehelper.GetQuoteChar(db), tableName, order.Desc))
		}
	}
	var total int64
	db.Model(res).Count(&total)
	if first != nil {
		db = db.Limit(*first)
	}
	if offset != nil {
		db = db.Offset(*offset)
	}
	db = db.Find(&res)
	if okHook {
		var err error
		res, err = v.AfterCallDb(ctx, res)
		if err != nil {
			return nil, err
		}
		res, err = v.BeforeReturn(ctx, res, db)
		if err != nil {
			return nil, err
		}
	}
	return &model.TodoQueryResult{
		Data:       res,
		Count:      len(res),
		TotalCount: int(total),
	}, db.Error
}
func (r *Resolver) AddTodoPayload() AddTodoPayloadResolver {
	return &todoPayloadResolver[*model.AddTodoPayload]{r}
}
func (r *Resolver) DeleteTodoPayload() DeleteTodoPayloadResolver {
	return &todoPayloadResolver[*model.DeleteTodoPayload]{r}
}
func (r *Resolver) UpdateTodoPayload() UpdateTodoPayloadResolver {
	return &todoPayloadResolver[*model.UpdateTodoPayload]{r}
}

type todoPayload interface {
	*model.AddTodoPayload | *model.DeleteTodoPayload | *model.UpdateTodoPayload
}

type todoPayloadResolver[T todoPayload] struct {
	*Resolver
}

func (r *todoPayloadResolver[T]) Todo(ctx context.Context, obj T, filter *model.TodoFiltersInput, order *model.TodoOrder, first *int, offset *int) (*model.TodoQueryResult, error) {
	return r.Query().QueryTodo(ctx, filter, order, first, offset)
}
func (r *mutationResolver) AddUser2Todos(ctx context.Context, input model.UserRef2TodosInput) (*model.UpdateTodoPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.AddUser2Todos)].(db.AutoGqlHookMany2Many[model.UserRef2TodosInput, model.UpdateTodoPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, &input)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Todo")
	blackList := make(map[string]struct{})
	sql, arguments := runtimehelper.CombineSimpleQuery(input.Filter.ExtendsDatabaseQuery(db, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
	db = db.Model(&model.Todo{}).Where(sql, arguments...)
	var res []*model.Todo
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	db.Find(&res)
	type TodoUsers struct {
		TodoID int
		UserID int
	}
	resIds := make([]map[string]interface{}, 0)
	for _, v := range res {
		for _, v1 := range input.Set {
			tmp := make(map[string]interface{})
			tmp["TodoID"] = v.ID
			tmp["UserID"] = v1
			resIds = append(resIds, tmp)
		}
	}
	d := r.Sql.Db.Model(&TodoUsers{}).Create(resIds)
	result := &model.UpdateTodoPayload{
		Count: int(d.RowsAffected),
	}
	if okHook {
		var err error
		result, err = v.BeforeReturn(ctx, db, result)
		if err != nil {
			return nil, err
		}
	}
	return result, d.Error
}

// AddTodo is the resolver for the addTodo field.
func (r *mutationResolver) AddTodo(ctx context.Context, input []*model.TodoInput) (*model.AddTodoPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.AddTodo)].(db.AutoGqlHookAdd[model.Todo, model.TodoInput, model.AddTodoPayload])
	res := &model.AddTodoPayload{}
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, input)
		if err != nil {
			return nil, err
		}
	}
	obj := make([]model.Todo, len(input))
	for i, v := range input {
		obj[i] = v.MergeToType()
	}
	db = db.Omit(clause.Associations)
	if okHook {
		var err error
		db, obj, err = v.BeforeCallDb(ctx, db, obj)
		if err != nil {
			return nil, err
		}
	}
	db = db.Create(&obj)
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, obj, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// UpdateTodo is the resolver for the updateTodo field.
func (r *mutationResolver) UpdateTodo(ctx context.Context, input model.UpdateTodoInput) (*model.UpdateTodoPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.UpdateTodo)].(db.AutoGqlHookUpdate[model.UpdateTodoInput, model.UpdateTodoPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, &input)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Todo")
	blackList := make(map[string]struct{})
	queryDb := db.Select(tableName + ".id")
	sql, arguments := runtimehelper.CombineSimpleQuery(input.Filter.ExtendsDatabaseQuery(queryDb, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
	obj := model.Todo{}
	queryDb = queryDb.Model(&obj).Where(sql, arguments...)
	var toChange []model.Todo
	queryDb.Find(&toChange)
	update := input.Set.MergeToType()
	if okHook {
		var err error
		db, update, err = v.BeforeCallDb(ctx, db, update)
		if err != nil {
			return nil, err
		}
	}
	ids := make([]int, len(toChange))
	for i, one := range toChange {
		ids[i] = one.ID
	}
	db = db.Model(&obj).Where("id IN ?", ids).Updates(update)
	res := &model.UpdateTodoPayload{
		Count: int(db.RowsAffected),
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// DeleteTodo is the resolver for the deleteTodo field.
func (r *mutationResolver) DeleteTodo(ctx context.Context, filter model.TodoFiltersInput) (*model.DeleteTodoPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.DeleteTodo)].(db.AutoGqlHookDelete[model.TodoFiltersInput, model.DeleteTodoPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, err = v.Received(ctx, r.Sql, &filter)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("Todo")
	blackList := make(map[string]struct{})
	queryDb := db.Select(tableName + ".id")
	sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(queryDb, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
	obj := model.Todo{}
	queryDb = queryDb.Model(&obj).Where(sql, arguments...)
	var toChange []model.Todo
	queryDb.Find(&toChange)
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	ids := make([]int, len(toChange))
	for i, one := range toChange {
		ids[i] = one.ID
	}
	db = db.Model(&obj).Where("id IN ?", ids).Delete(&obj)
	msg := fmt.Sprintf("%d rows deleted", db.RowsAffected)
	res := &model.DeleteTodoPayload{
		Count: int(db.RowsAffected),
		Msg:   &msg,
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// GetUser is the resolver for the getUser field.
func (r *queryResolver) GetUser(ctx context.Context, id int) (*model.User, error) {
	v, okHook := r.Sql.Hooks[string(db.GetUser)].(db.AutoGqlHookGet[model.User, int])
	db := r.Sql.Db
	if okHook {
		var err error
		db, err = v.Received(ctx, r.Sql, id)
		if err != nil {
			return nil, err
		}
	}
	db = runtimehelper.GetPreloadSelection(ctx, db, runtimehelper.GetPreloadsMap(ctx, "User"))
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	var res model.User
	db = db.First(&res, id)
	if okHook {
		r, err := v.AfterCallDb(ctx, &res)
		if err != nil {
			return nil, err
		}
		res = *r
		r, err = v.BeforeReturn(ctx, &res, db)
		if err != nil {
			return nil, err
		}
		res = *r
	}
	return &res, db.Error
}

// QueryUser is the resolver for the queryUser field.
func (r *queryResolver) QueryUser(ctx context.Context, filter *model.UserFiltersInput, order *model.UserOrder, first *int, offset *int) (*model.UserQueryResult, error) {
	v, okHook := r.Sql.Hooks[string(db.QueryUser)].(db.AutoGqlHookQuery[model.User, model.UserFiltersInput, model.UserOrder])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, order, first, offset, err = v.Received(ctx, r.Sql, filter, order, first, offset)
		if err != nil {
			return nil, err
		}
	}
	var res []*model.User
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("User")
	db = runtimehelper.GetPreloadSelection(ctx, db, runtimehelper.GetPreloadsMap(ctx, "data").SubTables[0])
	if filter != nil {
		blackList := make(map[string]struct{})
		sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(db, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
		db.Where(sql, arguments...)
	}

	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}

	if order != nil {
		if order.Asc != nil {
			db = db.Order(fmt.Sprintf("%[1]s%[2]s%[1]s.%[1]s%[3]s%[1]s asc", runtimehelper.GetQuoteChar(db), tableName, order.Asc))
		}
		if order.Desc != nil {
			db = db.Order(fmt.Sprintf("%[1]s%[2]s%[1]s.%[1]s%[3]s%[1]s desc", runtimehelper.GetQuoteChar(db), tableName, order.Desc))
		}
	}
	var total int64
	db.Model(res).Count(&total)
	if first != nil {
		db = db.Limit(*first)
	}
	if offset != nil {
		db = db.Offset(*offset)
	}
	db = db.Find(&res)
	if okHook {
		var err error
		res, err = v.AfterCallDb(ctx, res)
		if err != nil {
			return nil, err
		}
		res, err = v.BeforeReturn(ctx, res, db)
		if err != nil {
			return nil, err
		}
	}
	return &model.UserQueryResult{
		Data:       res,
		Count:      len(res),
		TotalCount: int(total),
	}, db.Error
}
func (r *Resolver) AddUserPayload() AddUserPayloadResolver {
	return &userPayloadResolver[*model.AddUserPayload]{r}
}
func (r *Resolver) DeleteUserPayload() DeleteUserPayloadResolver {
	return &userPayloadResolver[*model.DeleteUserPayload]{r}
}
func (r *Resolver) UpdateUserPayload() UpdateUserPayloadResolver {
	return &userPayloadResolver[*model.UpdateUserPayload]{r}
}

type userPayload interface {
	*model.AddUserPayload | *model.DeleteUserPayload | *model.UpdateUserPayload
}

type userPayloadResolver[T userPayload] struct {
	*Resolver
}

func (r *userPayloadResolver[T]) User(ctx context.Context, obj T, filter *model.UserFiltersInput, order *model.UserOrder, first *int, offset *int) (*model.UserQueryResult, error) {
	return r.Query().QueryUser(ctx, filter, order, first, offset)
}

// AddUser is the resolver for the addUser field.
func (r *mutationResolver) AddUser(ctx context.Context, input []*model.UserInput) (*model.AddUserPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.AddUser)].(db.AutoGqlHookAdd[model.User, model.UserInput, model.AddUserPayload])
	res := &model.AddUserPayload{}
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, input)
		if err != nil {
			return nil, err
		}
	}
	obj := make([]model.User, len(input))
	for i, v := range input {
		obj[i] = v.MergeToType()
	}
	db = db.Omit(clause.Associations)
	if okHook {
		var err error
		db, obj, err = v.BeforeCallDb(ctx, db, obj)
		if err != nil {
			return nil, err
		}
	}
	db = db.Create(&obj)
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, obj, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model.UpdateUserInput) (*model.UpdateUserPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.UpdateUser)].(db.AutoGqlHookUpdate[model.UpdateUserInput, model.UpdateUserPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, input, err = v.Received(ctx, r.Sql, &input)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("User")
	blackList := make(map[string]struct{})
	queryDb := db.Select(tableName + ".id")
	sql, arguments := runtimehelper.CombineSimpleQuery(input.Filter.ExtendsDatabaseQuery(queryDb, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
	obj := model.User{}
	queryDb = queryDb.Model(&obj).Where(sql, arguments...)
	var toChange []model.User
	queryDb.Find(&toChange)
	update := input.Set.MergeToType()
	if okHook {
		var err error
		db, update, err = v.BeforeCallDb(ctx, db, update)
		if err != nil {
			return nil, err
		}
	}
	ids := make([]int, len(toChange))
	for i, one := range toChange {
		ids[i] = one.ID
	}
	db = db.Model(&obj).Where("id IN ?", ids).Updates(update)
	res := &model.UpdateUserPayload{
		Count: int(db.RowsAffected),
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, filter model.UserFiltersInput) (*model.DeleteUserPayload, error) {
	v, okHook := r.Sql.Hooks[string(db.DeleteUser)].(db.AutoGqlHookDelete[model.UserFiltersInput, model.DeleteUserPayload])
	db := r.Sql.Db
	if okHook {
		var err error
		db, filter, err = v.Received(ctx, r.Sql, &filter)
		if err != nil {
			return nil, err
		}
	}
	tableName := r.Sql.Db.Config.NamingStrategy.TableName("User")
	blackList := make(map[string]struct{})
	queryDb := db.Select(tableName + ".id")
	sql, arguments := runtimehelper.CombineSimpleQuery(filter.ExtendsDatabaseQuery(queryDb, fmt.Sprintf("%[1]s%[2]s%[1]s", runtimehelper.GetQuoteChar(db), tableName), false, blackList), "AND")
	obj := model.User{}
	queryDb = queryDb.Model(&obj).Where(sql, arguments...)
	var toChange []model.User
	queryDb.Find(&toChange)
	if okHook {
		var err error
		db, err = v.BeforeCallDb(ctx, db)
		if err != nil {
			return nil, err
		}
	}
	ids := make([]int, len(toChange))
	for i, one := range toChange {
		ids[i] = one.ID
	}
	db = db.Model(&obj).Where("id IN ?", ids).Delete(&obj)
	msg := fmt.Sprintf("%d rows deleted", db.RowsAffected)
	res := &model.DeleteUserPayload{
		Count: int(db.RowsAffected),
		Msg:   &msg,
	}
	if okHook {
		var err error
		res, err = v.BeforeReturn(ctx, db, res)
		if err != nil {
			return nil, err
		}
	}
	return res, db.Error
}
