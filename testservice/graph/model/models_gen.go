// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

type AddTodoPayload struct {
	Todo *TodoQueryResult `json:"todo"`
}

type AddUserPayload struct {
	User *UserQueryResult `json:"user"`
}

type BooleanFilterInput struct {
	And     []*bool             `json:"and"`
	Or      []*bool             `json:"or"`
	Not     *BooleanFilterInput `json:"not"`
	Is      *bool               `json:"is"`
	Null    *bool               `json:"null"`
	NotNull *bool               `json:"notNull"`
}

type DeleteTodoPayload struct {
	Todo  *TodoQueryResult `json:"todo"`
	Count int              `json:"count"`
	Msg   *string          `json:"msg"`
}

type DeleteUserPayload struct {
	User  *UserQueryResult `json:"user"`
	Count int              `json:"count"`
	Msg   *string          `json:"msg"`
}

type IDFilterInput struct {
	And     []*string      `json:"and"`
	Or      []*string      `json:"or"`
	Not     *IDFilterInput `json:"not"`
	Eq      *string        `json:"eq"`
	Ne      *string        `json:"ne"`
	Null    *bool          `json:"null"`
	NotNull *bool          `json:"notNull"`
	In      []*string      `json:"in"`
	Notin   []*string      `json:"notin"`
}

type IntFilterBetween struct {
	Start int `json:"start"`
	End   int `json:"end"`
}

type IntFilterInput struct {
	And     []*int            `json:"and"`
	Or      []*int            `json:"or"`
	Not     *IntFilterInput   `json:"not"`
	Eq      *int              `json:"eq"`
	Ne      *int              `json:"ne"`
	Gt      *int              `json:"gt"`
	Gte     *int              `json:"gte"`
	Lt      *int              `json:"lt"`
	Lte     *int              `json:"lte"`
	Null    *bool             `json:"null"`
	NotNull *bool             `json:"notNull"`
	In      []*int            `json:"in"`
	NotIn   []*int            `json:"notIn"`
	Between *IntFilterBetween `json:"between"`
}

type SQLCreateExtension struct {
	Value        bool     `json:"value"`
	DirectiveExt []string `json:"directiveExt"`
}

type SQLMutationParams struct {
	Add          *SQLCreateExtension `json:"add"`
	Update       *SQLCreateExtension `json:"update"`
	Delete       *SQLCreateExtension `json:"delete"`
	DirectiveExt []string            `json:"directiveExt"`
}

type SQLQueryParams struct {
	Get          *SQLCreateExtension `json:"get"`
	Query        *SQLCreateExtension `json:"query"`
	DirectiveExt []string            `json:"directiveExt"`
}

type StringFilterInput struct {
	And          []*string          `json:"and"`
	Or           []*string          `json:"or"`
	Not          *StringFilterInput `json:"not"`
	Eq           *string            `json:"eq"`
	Eqi          *string            `json:"eqi"`
	Ne           *string            `json:"ne"`
	StartsWith   *string            `json:"startsWith"`
	EndsWith     *string            `json:"endsWith"`
	Contains     *string            `json:"contains"`
	NotContains  *string            `json:"notContains"`
	Containsi    *string            `json:"containsi"`
	NotContainsi *string            `json:"notContainsi"`
	Null         *bool              `json:"null"`
	NotNull      *bool              `json:"notNull"`
	In           []*string          `json:"in"`
	NotIn        []*string          `json:"notIn"`
}

type TimeFilterBetween struct {
	Start time.Time `json:"start"`
	End   time.Time `json:"end"`
}

type TimeFilterInput struct {
	And     []*time.Time       `json:"and"`
	Or      []*time.Time       `json:"or"`
	Not     *TimeFilterInput   `json:"not"`
	Eq      *time.Time         `json:"eq"`
	Ne      *time.Time         `json:"ne"`
	Gt      *time.Time         `json:"gt"`
	Gte     *time.Time         `json:"gte"`
	Lt      *time.Time         `json:"lt"`
	Lte     *time.Time         `json:"lte"`
	Null    *bool              `json:"null"`
	NotNull *bool              `json:"notNull"`
	In      []*time.Time       `json:"in"`
	NotIn   []*time.Time       `json:"notIn"`
	Between *TimeFilterBetween `json:"between"`
}

type Todo struct {
	ID        string     `json:"id" gorm:"primaryKey;autoIncrement;"`
	Name      string     `json:"name"`
	Users     []*User    `json:"users" gorm:"many2many:group_users;"`
	CreatedAt *time.Time `json:"createdAt"`
	UpdatedAt *time.Time `json:"updatedAt"`
	DeletedAt *time.Time `json:"deletedAt"`
}

type TodoFiltersInput struct {
	ID        *IDFilterInput      `json:"id"`
	Name      *StringFilterInput  `json:"name"`
	Users     *UserFiltersInput   `json:"users"`
	CreatedAt *TimeFilterInput    `json:"createdAt"`
	UpdatedAt *TimeFilterInput    `json:"updatedAt"`
	DeletedAt *TimeFilterInput    `json:"deletedAt"`
	And       []*TodoFiltersInput `json:"and"`
	Or        []*TodoFiltersInput `json:"or"`
	Not       *TodoFiltersInput   `json:"not"`
}

type TodoInput struct {
	Name  string       `json:"name"`
	Users []*UserInput `json:"users"`
}

type TodoOrder struct {
	Asc  *TodoOrderable `json:"asc"`
	Desc *TodoOrderable `json:"desc"`
}

type TodoPatch struct {
	Name  *string      `json:"name"`
	Users []*UserPatch `json:"users"`
}

type TodoQueryResult struct {
	Data       []*Todo `json:"data"`
	Count      int     `json:"count"`
	TotalCount int     `json:"totalCount"`
}

type UpdateTodoInput struct {
	Filter *TodoFiltersInput `json:"filter"`
	Set    *TodoPatch        `json:"set"`
}

type UpdateTodoPayload struct {
	Todo  *TodoQueryResult `json:"todo"`
	Count int              `json:"count"`
}

type UpdateUserInput struct {
	Filter *UserFiltersInput `json:"filter"`
	Set    *UserPatch        `json:"set"`
}

type UpdateUserPayload struct {
	User  *UserQueryResult `json:"user"`
	Count int              `json:"count"`
}

type User struct {
	ID        string     `json:"id" gorm:"primaryKey;autoIncrement;"`
	Name      string     `json:"name"`
	CreatedAt *time.Time `json:"createdAt"`
	UpdatedAt *time.Time `json:"updatedAt"`
	DeletedAt *time.Time `json:"deletedAt"`
}

type UserFiltersInput struct {
	ID        *IDFilterInput      `json:"id"`
	Name      *StringFilterInput  `json:"name"`
	CreatedAt *TimeFilterInput    `json:"createdAt"`
	UpdatedAt *TimeFilterInput    `json:"updatedAt"`
	DeletedAt *TimeFilterInput    `json:"deletedAt"`
	And       []*UserFiltersInput `json:"and"`
	Or        []*UserFiltersInput `json:"or"`
	Not       *UserFiltersInput   `json:"not"`
}

type UserInput struct {
	Name string `json:"name"`
}

type UserOrder struct {
	Asc  *UserOrderable `json:"asc"`
	Desc *UserOrderable `json:"desc"`
}

type UserPatch struct {
	Name *string `json:"name"`
}

type UserQueryResult struct {
	Data       []*User `json:"data"`
	Count      int     `json:"count"`
	TotalCount int     `json:"totalCount"`
}

type UserRef2TodosInput struct {
	Filter *TodoFiltersInput `json:"filter"`
	Set    []string          `json:"set"`
}

type TodoOrderable string

const (
	TodoOrderableID   TodoOrderable = "id"
	TodoOrderableName TodoOrderable = "name"
)

var AllTodoOrderable = []TodoOrderable{
	TodoOrderableID,
	TodoOrderableName,
}

func (e TodoOrderable) IsValid() bool {
	switch e {
	case TodoOrderableID, TodoOrderableName:
		return true
	}
	return false
}

func (e TodoOrderable) String() string {
	return string(e)
}

func (e *TodoOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TodoOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TodoOrderable", str)
	}
	return nil
}

func (e TodoOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserOrderable string

const (
	UserOrderableID   UserOrderable = "id"
	UserOrderableName UserOrderable = "name"
)

var AllUserOrderable = []UserOrderable{
	UserOrderableID,
	UserOrderableName,
}

func (e UserOrderable) IsValid() bool {
	switch e {
	case UserOrderableID, UserOrderableName:
		return true
	}
	return false
}

func (e UserOrderable) String() string {
	return string(e)
}

func (e *UserOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserOrderable", str)
	}
	return nil
}

func (e UserOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
