// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

// AddCat result with filterable data and affected rows
type AddCatPayload struct {
	Cat      *CatQueryResult `json:"cat"`
	Affected []*Cat          `json:"affected"`
}

// AddCompany result with filterable data and affected rows
type AddCompanyPayload struct {
	Company  *CompanyQueryResult `json:"company"`
	Affected []*Company          `json:"affected"`
}

// AddSmartPhone result with filterable data and affected rows
type AddSmartPhonePayload struct {
	SmartPhone *SmartPhoneQueryResult `json:"smartPhone"`
	Affected   []*SmartPhone          `json:"affected"`
}

// AddTodo result with filterable data and affected rows
type AddTodoPayload struct {
	Todo     *TodoQueryResult `json:"todo"`
	Affected []*Todo          `json:"affected"`
}

// AddUser result with filterable data and affected rows
type AddUserPayload struct {
	User     *UserQueryResult `json:"user"`
	Affected []*User          `json:"affected"`
}

// Boolean Filter simple datatypes
type BooleanFilterInput struct {
	And     []*bool             `json:"and,omitempty"`
	Or      []*bool             `json:"or,omitempty"`
	Not     *BooleanFilterInput `json:"not,omitempty"`
	Is      *bool               `json:"is,omitempty"`
	Null    *bool               `json:"null,omitempty"`
	NotNull *bool               `json:"notNull,omitempty"`
}

type Cat struct {
	ID       int       `json:"id" gorm:"primaryKey;autoIncrement;"`
	Name     string    `json:"name"`
	BirthDay time.Time `json:"birthDay"`
	Age      *int      `json:"age,omitempty" gorm:"-;"`
	UserID   int       `json:"userID"`
	Alive    *bool     `json:"alive,omitempty" gorm:"default:true;"`
}

// Filter input selection for Cat
// Can be used f.e.: by queryCat
type CatFiltersInput struct {
	ID       *IDFilterInput      `json:"id,omitempty"`
	Name     *StringFilterInput  `json:"name,omitempty"`
	BirthDay *TimeFilterInput    `json:"birthDay,omitempty"`
	UserID   *IntFilterInput     `json:"userID,omitempty"`
	Alive    *BooleanFilterInput `json:"alive,omitempty"`
	And      []*CatFiltersInput  `json:"and,omitempty"`
	Or       []*CatFiltersInput  `json:"or,omitempty"`
	Not      *CatFiltersInput    `json:"not,omitempty"`
}

// Cat Input value to add new Cat
type CatInput struct {
	Name     string    `json:"name"`
	BirthDay time.Time `json:"birthDay"`
	UserID   int       `json:"userID"`
	Alive    *bool     `json:"alive,omitempty"`
}

// Order Cat by asc or desc
type CatOrder struct {
	Asc  *CatOrderable `json:"asc,omitempty"`
	Desc *CatOrderable `json:"desc,omitempty"`
}

// Cat Patch value all values are optional to update Cat entities
type CatPatch struct {
	Name     *string    `json:"name,omitempty"`
	BirthDay *time.Time `json:"birthDay,omitempty"`
	UserID   *int       `json:"userID,omitempty"`
	Alive    *bool      `json:"alive,omitempty"`
}

// Cat result
type CatQueryResult struct {
	Data       []*Cat `json:"data"`
	Count      int    `json:"count"`
	TotalCount int    `json:"totalCount"`
}

type Company struct {
	ID              int        `json:"id" gorm:"primaryKey;autoIncrement;"`
	Name            string     `json:"name"`
	Description     *string    `json:"description,omitempty"`
	MotherCompanyID *int       `json:"motherCompanyID,omitempty"`
	MotherCompany   *Company   `json:"motherCompany,omitempty"`
	CreatedAt       *time.Time `json:"createdAt,omitempty"`
}

// Filter input selection for Company
// Can be used f.e.: by queryCompany
type CompanyFiltersInput struct {
	ID              *IDFilterInput         `json:"id,omitempty"`
	Name            *StringFilterInput     `json:"name,omitempty"`
	Description     *StringFilterInput     `json:"description,omitempty"`
	MotherCompanyID *IntFilterInput        `json:"motherCompanyID,omitempty"`
	MotherCompany   *CompanyFiltersInput   `json:"motherCompany,omitempty"`
	CreatedAt       *TimeFilterInput       `json:"createdAt,omitempty"`
	And             []*CompanyFiltersInput `json:"and,omitempty"`
	Or              []*CompanyFiltersInput `json:"or,omitempty"`
	Not             *CompanyFiltersInput   `json:"not,omitempty"`
}

// Company Input value to add new Company
type CompanyInput struct {
	Name            string        `json:"name"`
	Description     *string       `json:"description,omitempty"`
	MotherCompanyID *int          `json:"motherCompanyID,omitempty"`
	MotherCompany   *CompanyInput `json:"motherCompany,omitempty"`
}

// Order Company by asc or desc
type CompanyOrder struct {
	Asc  *CompanyOrderable `json:"asc,omitempty"`
	Desc *CompanyOrderable `json:"desc,omitempty"`
}

// Company Patch value all values are optional to update Company entities
type CompanyPatch struct {
	Name            *string       `json:"name,omitempty"`
	Description     *string       `json:"description,omitempty"`
	MotherCompanyID *int          `json:"motherCompanyID,omitempty"`
	MotherCompany   *CompanyPatch `json:"motherCompany,omitempty"`
}

// Company result
type CompanyQueryResult struct {
	Data       []*Company `json:"data"`
	Count      int        `json:"count"`
	TotalCount int        `json:"totalCount"`
}

// DeleteCat result with filterable data and count of affected entries
type DeleteCatPayload struct {
	Cat *CatQueryResult `json:"cat"`
	// Count of deleted Cat entities
	Count int     `json:"count"`
	Msg   *string `json:"msg,omitempty"`
}

// DeleteCompany result with filterable data and count of affected entries
type DeleteCompanyPayload struct {
	Company *CompanyQueryResult `json:"company"`
	// Count of deleted Company entities
	Count int     `json:"count"`
	Msg   *string `json:"msg,omitempty"`
}

// DeleteSmartPhone result with filterable data and count of affected entries
type DeleteSmartPhonePayload struct {
	SmartPhone *SmartPhoneQueryResult `json:"smartPhone"`
	// Count of deleted SmartPhone entities
	Count int     `json:"count"`
	Msg   *string `json:"msg,omitempty"`
}

// DeleteTodo result with filterable data and count of affected entries
type DeleteTodoPayload struct {
	Todo *TodoQueryResult `json:"todo"`
	// Count of deleted Todo entities
	Count int     `json:"count"`
	Msg   *string `json:"msg,omitempty"`
}

// DeleteUser result with filterable data and count of affected entries
type DeleteUserPayload struct {
	User *UserQueryResult `json:"user"`
	// Count of deleted User entities
	Count int     `json:"count"`
	Msg   *string `json:"msg,omitempty"`
}

// Filter between start and end (start > value < end)
type FloatFilterBetween struct {
	Start float64 `json:"start"`
	End   float64 `json:"end"`
}

// Float Filter simple datatypes
type FloatFilterInput struct {
	And     []*float64          `json:"and,omitempty"`
	Or      []*float64          `json:"or,omitempty"`
	Not     *FloatFilterInput   `json:"not,omitempty"`
	Eq      *float64            `json:"eq,omitempty"`
	Ne      *float64            `json:"ne,omitempty"`
	Gt      *float64            `json:"gt,omitempty"`
	Gte     *float64            `json:"gte,omitempty"`
	Lt      *float64            `json:"lt,omitempty"`
	Lte     *float64            `json:"lte,omitempty"`
	Null    *bool               `json:"null,omitempty"`
	NotNull *bool               `json:"notNull,omitempty"`
	In      []*float64          `json:"in,omitempty"`
	NotIn   []*float64          `json:"notIn,omitempty"`
	Between *FloatFilterBetween `json:"between,omitempty"`
}

// ID Filter simple datatypes
type IDFilterInput struct {
	And     []*int         `json:"and,omitempty"`
	Or      []*int         `json:"or,omitempty"`
	Not     *IDFilterInput `json:"not,omitempty"`
	Eq      *int           `json:"eq,omitempty"`
	Ne      *int           `json:"ne,omitempty"`
	Null    *bool          `json:"null,omitempty"`
	NotNull *bool          `json:"notNull,omitempty"`
	In      []*int         `json:"in,omitempty"`
	Notin   []*int         `json:"notin,omitempty"`
}

// Filter between start and end (start > value < end)
type IntFilterBetween struct {
	Start int `json:"start"`
	End   int `json:"end"`
}

// Int Filter simple datatypes
type IntFilterInput struct {
	And     []*int            `json:"and,omitempty"`
	Or      []*int            `json:"or,omitempty"`
	Not     *IntFilterInput   `json:"not,omitempty"`
	Eq      *int              `json:"eq,omitempty"`
	Ne      *int              `json:"ne,omitempty"`
	Gt      *int              `json:"gt,omitempty"`
	Gte     *int              `json:"gte,omitempty"`
	Lt      *int              `json:"lt,omitempty"`
	Lte     *int              `json:"lte,omitempty"`
	Null    *bool             `json:"null,omitempty"`
	NotNull *bool             `json:"notNull,omitempty"`
	In      []*int            `json:"in,omitempty"`
	NotIn   []*int            `json:"notIn,omitempty"`
	Between *IntFilterBetween `json:"between,omitempty"`
}

type NoSQLControl struct {
	ID int     `json:"id"`
	A  *string `json:"a,omitempty"`
	B  int     `json:"b"`
}

type SmartPhone struct {
	ID          int    `json:"id" gorm:"primaryKey;autoIncrement;"`
	Brand       string `json:"brand"`
	Phonenumber string `json:"phonenumber"`
	UserID      int    `json:"userID"`
}

// Filter input selection for SmartPhone
// Can be used f.e.: by querySmartPhone
type SmartPhoneFiltersInput struct {
	ID          *IDFilterInput            `json:"id,omitempty"`
	Brand       *StringFilterInput        `json:"brand,omitempty"`
	Phonenumber *StringFilterInput        `json:"phonenumber,omitempty"`
	UserID      *IDFilterInput            `json:"userID,omitempty"`
	And         []*SmartPhoneFiltersInput `json:"and,omitempty"`
	Or          []*SmartPhoneFiltersInput `json:"or,omitempty"`
	Not         *SmartPhoneFiltersInput   `json:"not,omitempty"`
}

// SmartPhone Input value to add new SmartPhone
type SmartPhoneInput struct {
	Brand       string `json:"brand"`
	Phonenumber string `json:"phonenumber"`
	UserID      int    `json:"userID"`
}

// Order SmartPhone by asc or desc
type SmartPhoneOrder struct {
	Asc  *SmartPhoneOrderable `json:"asc,omitempty"`
	Desc *SmartPhoneOrderable `json:"desc,omitempty"`
}

// SmartPhone Patch value all values are optional to update SmartPhone entities
type SmartPhonePatch struct {
	Brand       *string `json:"brand,omitempty"`
	Phonenumber *string `json:"phonenumber,omitempty"`
	UserID      *int    `json:"userID,omitempty"`
}

// SmartPhone result
type SmartPhoneQueryResult struct {
	Data       []*SmartPhone `json:"data"`
	Count      int           `json:"count"`
	TotalCount int           `json:"totalCount"`
}

type SQLCreateExtension struct {
	Value        bool     `json:"value"`
	DirectiveExt []string `json:"directiveExt,omitempty"`
}

type SQLMutationParams struct {
	Add          *SQLCreateExtension `json:"add,omitempty"`
	Update       *SQLCreateExtension `json:"update,omitempty"`
	Delete       *SQLCreateExtension `json:"delete,omitempty"`
	DirectiveExt []string            `json:"directiveExt,omitempty"`
}

type SQLQueryParams struct {
	Get          *SQLCreateExtension `json:"get,omitempty"`
	Query        *SQLCreateExtension `json:"query,omitempty"`
	DirectiveExt []string            `json:"directiveExt,omitempty"`
}

// String Filter simple datatypes
type StringFilterInput struct {
	And          []*string          `json:"and,omitempty"`
	Or           []*string          `json:"or,omitempty"`
	Not          *StringFilterInput `json:"not,omitempty"`
	Eq           *string            `json:"eq,omitempty"`
	Eqi          *string            `json:"eqi,omitempty"`
	Ne           *string            `json:"ne,omitempty"`
	StartsWith   *string            `json:"startsWith,omitempty"`
	EndsWith     *string            `json:"endsWith,omitempty"`
	Contains     *string            `json:"contains,omitempty"`
	NotContains  *string            `json:"notContains,omitempty"`
	Containsi    *string            `json:"containsi,omitempty"`
	NotContainsi *string            `json:"notContainsi,omitempty"`
	Null         *bool              `json:"null,omitempty"`
	NotNull      *bool              `json:"notNull,omitempty"`
	In           []*string          `json:"in,omitempty"`
	NotIn        []*string          `json:"notIn,omitempty"`
}

// Filter between start and end (start > value < end)
type TimeFilterBetween struct {
	Start time.Time `json:"start"`
	End   time.Time `json:"end"`
}

// Time Filter simple datatypes
type TimeFilterInput struct {
	And     []*time.Time       `json:"and,omitempty"`
	Or      []*time.Time       `json:"or,omitempty"`
	Not     *TimeFilterInput   `json:"not,omitempty"`
	Eq      *time.Time         `json:"eq,omitempty"`
	Ne      *time.Time         `json:"ne,omitempty"`
	Gt      *time.Time         `json:"gt,omitempty"`
	Gte     *time.Time         `json:"gte,omitempty"`
	Lt      *time.Time         `json:"lt,omitempty"`
	Lte     *time.Time         `json:"lte,omitempty"`
	Null    *bool              `json:"null,omitempty"`
	NotNull *bool              `json:"notNull,omitempty"`
	In      []*time.Time       `json:"in,omitempty"`
	NotIn   []*time.Time       `json:"notIn,omitempty"`
	Between *TimeFilterBetween `json:"between,omitempty"`
}

// Filter input selection for Todo
// Can be used f.e.: by queryTodo
type TodoFiltersInput struct {
	ID        *IDFilterInput      `json:"id,omitempty"`
	Name      *StringFilterInput  `json:"name,omitempty"`
	Users     *UserFiltersInput   `json:"users,omitempty"`
	Owner     *UserFiltersInput   `json:"owner,omitempty"`
	OwnerID   *IDFilterInput      `json:"ownerID,omitempty"`
	CreatedAt *TimeFilterInput    `json:"createdAt,omitempty"`
	UpdatedAt *TimeFilterInput    `json:"updatedAt,omitempty"`
	DeletedAt *TimeFilterInput    `json:"deletedAt,omitempty"`
	Etype1    *StringFilterInput  `json:"etype1,omitempty"`
	Etype5    *StringFilterInput  `json:"etype5,omitempty"`
	And       []*TodoFiltersInput `json:"and,omitempty"`
	Or        []*TodoFiltersInput `json:"or,omitempty"`
	Not       *TodoFiltersInput   `json:"not,omitempty"`
}

// Todo Input value to add new Todo
type TodoInput struct {
	Name    string    `json:"name"`
	Etype1  *TodoType `json:"etype1,omitempty"`
	Etype5  TodoType  `json:"etype5"`
	Test123 *string   `json:"test123,omitempty"`
}

// Order Todo by asc or desc
type TodoOrder struct {
	Asc  *TodoOrderable `json:"asc,omitempty"`
	Desc *TodoOrderable `json:"desc,omitempty"`
}

// Todo Patch value all values are optional to update Todo entities
type TodoPatch struct {
	Name    *string   `json:"name,omitempty"`
	Etype1  *TodoType `json:"etype1,omitempty"`
	Etype5  *TodoType `json:"etype5,omitempty"`
	Test123 *string   `json:"test123,omitempty"`
}

// Todo result
type TodoQueryResult struct {
	Data       []*Todo `json:"data"`
	Count      int     `json:"count"`
	TotalCount int     `json:"totalCount"`
}

// Update rules for Cat multiupdates simple possible by global filtervalue
type UpdateCatInput struct {
	Filter *CatFiltersInput `json:"filter"`
	Set    *CatPatch        `json:"set"`
}

// UpdateCat result with filterable data and affected rows
type UpdateCatPayload struct {
	Cat *CatQueryResult `json:"cat"`
	// Count of affected updates
	Count    int    `json:"count"`
	Affected []*Cat `json:"affected"`
}

// Update rules for Company multiupdates simple possible by global filtervalue
type UpdateCompanyInput struct {
	Filter *CompanyFiltersInput `json:"filter"`
	Set    *CompanyPatch        `json:"set"`
}

// UpdateCompany result with filterable data and affected rows
type UpdateCompanyPayload struct {
	Company *CompanyQueryResult `json:"company"`
	// Count of affected updates
	Count    int        `json:"count"`
	Affected []*Company `json:"affected"`
}

// Update rules for SmartPhone multiupdates simple possible by global filtervalue
type UpdateSmartPhoneInput struct {
	Filter *SmartPhoneFiltersInput `json:"filter"`
	Set    *SmartPhonePatch        `json:"set"`
}

// UpdateSmartPhone result with filterable data and affected rows
type UpdateSmartPhonePayload struct {
	SmartPhone *SmartPhoneQueryResult `json:"smartPhone"`
	// Count of affected updates
	Count    int           `json:"count"`
	Affected []*SmartPhone `json:"affected"`
}

// Update rules for Todo multiupdates simple possible by global filtervalue
type UpdateTodoInput struct {
	Filter *TodoFiltersInput `json:"filter"`
	Set    *TodoPatch        `json:"set"`
}

// UpdateTodo result with filterable data and affected rows
type UpdateTodoPayload struct {
	Todo *TodoQueryResult `json:"todo"`
	// Count of affected updates
	Count    int     `json:"count"`
	Affected []*Todo `json:"affected"`
}

// Update rules for User multiupdates simple possible by global filtervalue
type UpdateUserInput struct {
	Filter *UserFiltersInput `json:"filter"`
	Set    *UserPatch        `json:"set"`
}

// UpdateUser result with filterable data and affected rows
type UpdateUserPayload struct {
	User *UserQueryResult `json:"user"`
	// Count of affected updates
	Count    int     `json:"count"`
	Affected []*User `json:"affected"`
}

type User struct {
	ID           int           `json:"id" gorm:"primaryKey;autoIncrement;"`
	Name         string        `json:"name"`
	CreatedAt    *time.Time    `json:"createdAt,omitempty"`
	UpdatedAt    *time.Time    `json:"updatedAt,omitempty"`
	DeletedAt    *time.Time    `json:"deletedAt,omitempty"`
	Cat          *Cat          `json:"cat,omitempty" gorm:"constraint:OnUpdate:CASCADE,OnDelete:SET NULL;;"`
	CompanyID    *int          `json:"companyID,omitempty"`
	Money        *float64      `json:"money,omitempty"`
	Company      *Company      `json:"company,omitempty"`
	SmartPhones  []*SmartPhone `json:"smartPhones,omitempty"`
	FavoritColor *string       `json:"favoritColor,omitempty"`
	Email        string        `json:"email"`
}

// Filter input selection for User
// Can be used f.e.: by queryUser
type UserFiltersInput struct {
	ID           *IDFilterInput          `json:"id,omitempty"`
	Name         *StringFilterInput      `json:"name,omitempty"`
	CreatedAt    *TimeFilterInput        `json:"createdAt,omitempty"`
	UpdatedAt    *TimeFilterInput        `json:"updatedAt,omitempty"`
	DeletedAt    *TimeFilterInput        `json:"deletedAt,omitempty"`
	Cat          *CatFiltersInput        `json:"cat,omitempty"`
	CompanyID    *IntFilterInput         `json:"companyID,omitempty"`
	Money        *FloatFilterInput       `json:"money,omitempty"`
	Company      *CompanyFiltersInput    `json:"company,omitempty"`
	SmartPhones  *SmartPhoneFiltersInput `json:"smartPhones,omitempty"`
	FavoritColor *StringFilterInput      `json:"favoritColor,omitempty"`
	Email        *StringFilterInput      `json:"email,omitempty"`
	And          []*UserFiltersInput     `json:"and,omitempty"`
	Or           []*UserFiltersInput     `json:"or,omitempty"`
	Not          *UserFiltersInput       `json:"not,omitempty"`
}

// User Input value to add new User
type UserInput struct {
	Name         string             `json:"name"`
	Cat          *CatInput          `json:"cat,omitempty"`
	CompanyID    *int               `json:"companyID,omitempty"`
	Money        *float64           `json:"money,omitempty"`
	Company      *CompanyInput      `json:"company,omitempty"`
	SmartPhones  []*SmartPhoneInput `json:"smartPhones,omitempty"`
	FavoritColor *string            `json:"favoritColor,omitempty" validate:"omitempty,hexcolor|rgb|rgba"`
	Email        string             `json:"email" validate:"required,email"`
}

// Order User by asc or desc
type UserOrder struct {
	Asc  *UserOrderable `json:"asc,omitempty"`
	Desc *UserOrderable `json:"desc,omitempty"`
}

// User Patch value all values are optional to update User entities
type UserPatch struct {
	Name         *string            `json:"name,omitempty"`
	Cat          *CatPatch          `json:"cat,omitempty"`
	CompanyID    *int               `json:"companyID,omitempty"`
	Money        *float64           `json:"money,omitempty"`
	Company      *CompanyPatch      `json:"company,omitempty"`
	SmartPhones  []*SmartPhonePatch `json:"smartPhones,omitempty"`
	FavoritColor *string            `json:"favoritColor,omitempty" validate:"omitempty,hexcolor|rgb|rgba"`
	Email        *string            `json:"email,omitempty" validate:"required,email"`
}

// User result
type UserQueryResult struct {
	Data       []*User `json:"data"`
	Count      int     `json:"count"`
	TotalCount int     `json:"totalCount"`
}

// Many 2 many input between Todo and User
// Filter to Select Todo and set to set list of User PrimaryKeys
type UserRef2TodosInput struct {
	Filter *TodoFiltersInput `json:"filter"`
	Set    []int             `json:"set"`
}

// Groupable data for  Cat
// Can be used f.e.: by queryCat
type CatGroup string

const (
	CatGroupID       CatGroup = "id"
	CatGroupName     CatGroup = "name"
	CatGroupBirthDay CatGroup = "birthDay"
	CatGroupUserID   CatGroup = "userID"
	CatGroupAlive    CatGroup = "alive"
)

var AllCatGroup = []CatGroup{
	CatGroupID,
	CatGroupName,
	CatGroupBirthDay,
	CatGroupUserID,
	CatGroupAlive,
}

func (e CatGroup) IsValid() bool {
	switch e {
	case CatGroupID, CatGroupName, CatGroupBirthDay, CatGroupUserID, CatGroupAlive:
		return true
	}
	return false
}

func (e CatGroup) String() string {
	return string(e)
}

func (e *CatGroup) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CatGroup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CatGroup", str)
	}
	return nil
}

func (e CatGroup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// for Cat a enum of all orderable entities
// can be used f.e.: queryCat
type CatOrderable string

const (
	CatOrderableID     CatOrderable = "id"
	CatOrderableName   CatOrderable = "name"
	CatOrderableUserID CatOrderable = "userID"
	CatOrderableAlive  CatOrderable = "alive"
)

var AllCatOrderable = []CatOrderable{
	CatOrderableID,
	CatOrderableName,
	CatOrderableUserID,
	CatOrderableAlive,
}

func (e CatOrderable) IsValid() bool {
	switch e {
	case CatOrderableID, CatOrderableName, CatOrderableUserID, CatOrderableAlive:
		return true
	}
	return false
}

func (e CatOrderable) String() string {
	return string(e)
}

func (e *CatOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CatOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CatOrderable", str)
	}
	return nil
}

func (e CatOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Groupable data for  Company
// Can be used f.e.: by queryCompany
type CompanyGroup string

const (
	CompanyGroupID              CompanyGroup = "id"
	CompanyGroupName            CompanyGroup = "name"
	CompanyGroupDescription     CompanyGroup = "description"
	CompanyGroupMotherCompanyID CompanyGroup = "motherCompanyID"
	CompanyGroupCreatedAt       CompanyGroup = "createdAt"
)

var AllCompanyGroup = []CompanyGroup{
	CompanyGroupID,
	CompanyGroupName,
	CompanyGroupDescription,
	CompanyGroupMotherCompanyID,
	CompanyGroupCreatedAt,
}

func (e CompanyGroup) IsValid() bool {
	switch e {
	case CompanyGroupID, CompanyGroupName, CompanyGroupDescription, CompanyGroupMotherCompanyID, CompanyGroupCreatedAt:
		return true
	}
	return false
}

func (e CompanyGroup) String() string {
	return string(e)
}

func (e *CompanyGroup) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CompanyGroup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CompanyGroup", str)
	}
	return nil
}

func (e CompanyGroup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// for Company a enum of all orderable entities
// can be used f.e.: queryCompany
type CompanyOrderable string

const (
	CompanyOrderableID              CompanyOrderable = "id"
	CompanyOrderableName            CompanyOrderable = "name"
	CompanyOrderableDescription     CompanyOrderable = "description"
	CompanyOrderableMotherCompanyID CompanyOrderable = "motherCompanyID"
)

var AllCompanyOrderable = []CompanyOrderable{
	CompanyOrderableID,
	CompanyOrderableName,
	CompanyOrderableDescription,
	CompanyOrderableMotherCompanyID,
}

func (e CompanyOrderable) IsValid() bool {
	switch e {
	case CompanyOrderableID, CompanyOrderableName, CompanyOrderableDescription, CompanyOrderableMotherCompanyID:
		return true
	}
	return false
}

func (e CompanyOrderable) String() string {
	return string(e)
}

func (e *CompanyOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CompanyOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CompanyOrderable", str)
	}
	return nil
}

func (e CompanyOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Groupable data for  SmartPhone
// Can be used f.e.: by querySmartPhone
type SmartPhoneGroup string

const (
	SmartPhoneGroupID          SmartPhoneGroup = "id"
	SmartPhoneGroupBrand       SmartPhoneGroup = "brand"
	SmartPhoneGroupPhonenumber SmartPhoneGroup = "phonenumber"
	SmartPhoneGroupUserID      SmartPhoneGroup = "userID"
)

var AllSmartPhoneGroup = []SmartPhoneGroup{
	SmartPhoneGroupID,
	SmartPhoneGroupBrand,
	SmartPhoneGroupPhonenumber,
	SmartPhoneGroupUserID,
}

func (e SmartPhoneGroup) IsValid() bool {
	switch e {
	case SmartPhoneGroupID, SmartPhoneGroupBrand, SmartPhoneGroupPhonenumber, SmartPhoneGroupUserID:
		return true
	}
	return false
}

func (e SmartPhoneGroup) String() string {
	return string(e)
}

func (e *SmartPhoneGroup) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SmartPhoneGroup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SmartPhoneGroup", str)
	}
	return nil
}

func (e SmartPhoneGroup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// for SmartPhone a enum of all orderable entities
// can be used f.e.: querySmartPhone
type SmartPhoneOrderable string

const (
	SmartPhoneOrderableID          SmartPhoneOrderable = "id"
	SmartPhoneOrderableBrand       SmartPhoneOrderable = "brand"
	SmartPhoneOrderablePhonenumber SmartPhoneOrderable = "phonenumber"
	SmartPhoneOrderableUserID      SmartPhoneOrderable = "userID"
)

var AllSmartPhoneOrderable = []SmartPhoneOrderable{
	SmartPhoneOrderableID,
	SmartPhoneOrderableBrand,
	SmartPhoneOrderablePhonenumber,
	SmartPhoneOrderableUserID,
}

func (e SmartPhoneOrderable) IsValid() bool {
	switch e {
	case SmartPhoneOrderableID, SmartPhoneOrderableBrand, SmartPhoneOrderablePhonenumber, SmartPhoneOrderableUserID:
		return true
	}
	return false
}

func (e SmartPhoneOrderable) String() string {
	return string(e)
}

func (e *SmartPhoneOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SmartPhoneOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SmartPhoneOrderable", str)
	}
	return nil
}

func (e SmartPhoneOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Groupable data for  Todo
// Can be used f.e.: by queryTodo
type TodoGroup string

const (
	TodoGroupID        TodoGroup = "id"
	TodoGroupName      TodoGroup = "name"
	TodoGroupOwnerID   TodoGroup = "ownerID"
	TodoGroupCreatedAt TodoGroup = "createdAt"
	TodoGroupUpdatedAt TodoGroup = "updatedAt"
	TodoGroupDeletedAt TodoGroup = "deletedAt"
)

var AllTodoGroup = []TodoGroup{
	TodoGroupID,
	TodoGroupName,
	TodoGroupOwnerID,
	TodoGroupCreatedAt,
	TodoGroupUpdatedAt,
	TodoGroupDeletedAt,
}

func (e TodoGroup) IsValid() bool {
	switch e {
	case TodoGroupID, TodoGroupName, TodoGroupOwnerID, TodoGroupCreatedAt, TodoGroupUpdatedAt, TodoGroupDeletedAt:
		return true
	}
	return false
}

func (e TodoGroup) String() string {
	return string(e)
}

func (e *TodoGroup) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TodoGroup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TodoGroup", str)
	}
	return nil
}

func (e TodoGroup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// for Todo a enum of all orderable entities
// can be used f.e.: queryTodo
type TodoOrderable string

const (
	TodoOrderableID      TodoOrderable = "id"
	TodoOrderableName    TodoOrderable = "name"
	TodoOrderableOwnerID TodoOrderable = "ownerID"
)

var AllTodoOrderable = []TodoOrderable{
	TodoOrderableID,
	TodoOrderableName,
	TodoOrderableOwnerID,
}

func (e TodoOrderable) IsValid() bool {
	switch e {
	case TodoOrderableID, TodoOrderableName, TodoOrderableOwnerID:
		return true
	}
	return false
}

func (e TodoOrderable) String() string {
	return string(e)
}

func (e *TodoOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TodoOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TodoOrderable", str)
	}
	return nil
}

func (e TodoOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TodoType string

const (
	TodoTypeBug     TodoType = "Bug"
	TodoTypeFeature TodoType = "Feature"
)

var AllTodoType = []TodoType{
	TodoTypeBug,
	TodoTypeFeature,
}

func (e TodoType) IsValid() bool {
	switch e {
	case TodoTypeBug, TodoTypeFeature:
		return true
	}
	return false
}

func (e TodoType) String() string {
	return string(e)
}

func (e *TodoType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TodoType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TodoType", str)
	}
	return nil
}

func (e TodoType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Groupable data for  User
// Can be used f.e.: by queryUser
type UserGroup string

const (
	UserGroupID           UserGroup = "id"
	UserGroupName         UserGroup = "name"
	UserGroupCreatedAt    UserGroup = "createdAt"
	UserGroupUpdatedAt    UserGroup = "updatedAt"
	UserGroupDeletedAt    UserGroup = "deletedAt"
	UserGroupCompanyID    UserGroup = "companyID"
	UserGroupMoney        UserGroup = "money"
	UserGroupFavoritColor UserGroup = "favoritColor"
	UserGroupEmail        UserGroup = "email"
)

var AllUserGroup = []UserGroup{
	UserGroupID,
	UserGroupName,
	UserGroupCreatedAt,
	UserGroupUpdatedAt,
	UserGroupDeletedAt,
	UserGroupCompanyID,
	UserGroupMoney,
	UserGroupFavoritColor,
	UserGroupEmail,
}

func (e UserGroup) IsValid() bool {
	switch e {
	case UserGroupID, UserGroupName, UserGroupCreatedAt, UserGroupUpdatedAt, UserGroupDeletedAt, UserGroupCompanyID, UserGroupMoney, UserGroupFavoritColor, UserGroupEmail:
		return true
	}
	return false
}

func (e UserGroup) String() string {
	return string(e)
}

func (e *UserGroup) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserGroup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserGroup", str)
	}
	return nil
}

func (e UserGroup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// for User a enum of all orderable entities
// can be used f.e.: queryUser
type UserOrderable string

const (
	UserOrderableID           UserOrderable = "id"
	UserOrderableName         UserOrderable = "name"
	UserOrderableCompanyID    UserOrderable = "companyID"
	UserOrderableMoney        UserOrderable = "money"
	UserOrderableFavoritColor UserOrderable = "favoritColor"
	UserOrderableEmail        UserOrderable = "email"
)

var AllUserOrderable = []UserOrderable{
	UserOrderableID,
	UserOrderableName,
	UserOrderableCompanyID,
	UserOrderableMoney,
	UserOrderableFavoritColor,
	UserOrderableEmail,
}

func (e UserOrderable) IsValid() bool {
	switch e {
	case UserOrderableID, UserOrderableName, UserOrderableCompanyID, UserOrderableMoney, UserOrderableFavoritColor, UserOrderableEmail:
		return true
	}
	return false
}

func (e UserOrderable) String() string {
	return string(e)
}

func (e *UserOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserOrderable", str)
	}
	return nil
}

func (e UserOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
